Filename,Buggy/Deleted,Fixed/Added
".pre-commit-config.yaml
",-    rev: v4.1.0,+    rev: v4.3.0
".pre-commit-config.yaml
",-    rev: 4.0.1,+    rev: 5.0.4
".pre-commit-config.yaml
",-    rev: v2.31.0,+    rev: v2.37.3
".pre-commit-config.yaml
",-    rev: v2.6.0,+    rev: v3.8.2
"ecdsa_base.py
",-            T = bytes(),+            T = b''
,,+## MacOS openssl error
,,+If you get the error that says something like `the libcrypto is running on unsafe mode` and the process is aborted:
,,+
,,+```sh
,,+brew install openssl
,,+sudo ln -s /opt/homebrew/opt/openssl@1.1/lib/libcrypto.1.1.dylib /usr/local/lib
,,+sudo ln -s /opt/homebrew/opt/openssl@1.1/lib/libssl.1.1.dylib /usr/local/lib
,,+cd /usr/local/lib
,,+sudo ln -s libcrypto.3.dylib libcrypto.dylib
,,+sudo ln -s libssl.3.dylib libssl.dylib
,,+```
,,+
,,+MacOS:
,,+```sh
,,+brew install autoconf automake libtool
,,+```
,,+
".pre-commit-config.yaml
",-    rev: v2.29.1,+    rev: v2.31.0
".pre-commit-config.yaml
",-    rev: v4.0.1,+    rev: v4.1.0
".pre-commit-config.yaml
",-    rev: v0.31.0,+    rev: v0.32.0
,,+
,,+
,,+
,,+
,,+
,,+
,,+
,,+
,,+
,,+
,,+
"README.md
",-sudo apt-get install build-essential libssl-dev libffi-dev python3-dev,+sudo apt-get install build-essential libssl-dev libffi-dev python3-dev autoconf libtool pkgconf
"README.md
",-[![PyPI version](https://badge.fury.io/py/evmoswallet.svg)](https://badge.fury.io/py/evmoswallet)[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/hanchon-live/evmoswallet/master.svg)](https://results.pre-commit.ci/latest/github/hanchon-live/evmoswallet/master),+[![PyPI version](https://badge.fury.io/py/evmoswallet.svg)](https://badge.fury.io/py/evmoswallet) [![pre-commit.ci status](https://results.pre-commit.ci/badge/github/hanchon-live/evmoswallet/master.svg)](https://results.pre-commit.ci/latest/github/hanchon-live/evmoswallet/master)
,,+## Requirements
,,+The cryptocurve dependency requires some libs to be built:
,,+
,,+```sh
,,+sudo apt-get install build-essential libssl-dev libffi-dev python3-dev
,,+```
,,+
".pre-commit-config.yaml
",-    rev: v2.29.0,+    rev: v2.29.1
".pre-commit-config.yaml
",-  - repo: https://gitlab.com/pycqa/flake8,+  - repo: https://github.com/PyCQA/flake8
".pre-commit-config.yaml
",-    rev: 3.9.2,+    rev: 4.0.1
,,+name: pytest
,,+on:
,,+  push:
,,+    branches: [master]
,,+  pull_request:
,,+jobs:
,,+  build:
,,+    runs-on: ubuntu-latest
,,+    steps:
,,+      - uses: actions/checkout@v2
,,+
,,+      - name: Set up Python
,,+        uses: actions/setup-python@v2
,,+        with:
,,"+          python-version: ""3.9"""
,,+
,,+      - name: Display Python version
,,"+        run: python -c ""import sys; print(sys.version)"""
,,+
,,+      - name: Install requirements
,,+        run: pip install -r requirements.txt && pip install pytest
,,+
,,+      - name: Run pytest
,,+        run: pytest
"README.md
",-[pywallet](https://github.com/ranaroussi/pywallet/),+[![PyPI version](https://badge.fury.io/py/evmoswallet.svg)](https://badge.fury.io/py/evmoswallet)[![pre-commit.ci status](https://results.pre-commit.ci/badge/github/hanchon-live/evmoswallet/master.svg)](https://results.pre-commit.ci/latest/github/hanchon-live/evmoswallet/master)
"README.md
",-[tow1](https://pypi.org/project/two1/),+
,,+- [pywallet](https://github.com/ranaroussi/pywallet/)
,,+- [tow1](https://pypi.org/project/two1/)
"setup.cfg
",-version = 1.0.3,+version = 1.0.4
"__init__.py
","-        res = f'{res}{format(w, ""x"")}'","+        res = f'{res}{format(w, ""x"").zfill(2)}'"
"setup.cfg
",-version = 1.0.2,+version = 1.0.3
"setup.cfg
",-python_requires = >=3.9,+    base58==2.1.0
"setup.cfg
",-    base58 == 2.1.0,+    mnemonic==0.20
"setup.cfg
",-    pycryptodomex==3.11.0,+    pycryptodomex==3.11.0
"setup.cfg
",-    mnemonic == 0.20,+python_requires = >=3.6
"utils.py
","-        return bytes([random.randint(0, 255) for i in range(n)])","+        return bytes(random.randint(0, 255) for i in range(n))"
".pre-commit-config.yaml
",-    rev: v2.4.0,+    rev: v4.0.1
".pre-commit-config.yaml
",-    rev: 3.8.0,+    rev: 3.9.2
".pre-commit-config.yaml
",-    rev: v2.4.1,+    rev: v2.29.0
".pre-commit-config.yaml
",-    rev: v2.3.0,+    rev: v2.6.0
"README.md
",-Evmos wallet utils for python3.,+Evmos wallet utils for `python3.9+`.
"README.md
",-seed = 'report spend crisp crisp world shock morning hour spoon problem one hole program piano donkey width today view canoe clap brick bundle rose book',+seed = 'report spend crisp crisp world shock morning hour ' \
"README.md
",-,+       'spoon problem one hole program piano donkey width ' \
"README.md
","-print(wallet.eth_address) # ""0xe7e3654bc1ea915e7216d8193ef8dd7d5dae987f""",+       'today view canoe clap brick bundle rose book'
"README.md
","-print(wallet.evmos_address) # ""evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5""",+
"README.md
","-print(wallet.private_key) # bytes.fromhex(""8721109b7244925c0480f4172546b8b53dfe87845274070fbe8e6da739d1b813"")",+print(wallet.eth_address)
"setup.cfg
",-version = 1.0.1,"+# ""0xe7e3654bc1ea915e7216d8193ef8dd7d5dae987f"""
"setup.cfg
",-python_requires = >=3.6,+print(wallet.evmos_address)
,,"+# ""evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5"""
,,+print(wallet.private_key)
,,"+# bytes.fromhex(""8721109b7244925c0480f4172546b8b53dfe87845274070fbe8e6da739d1b813"")"
,,+version = 1.0.2
,,+python_requires = >=3.9
"__init__.py
",-            # acct_pub_key = acct_priv_key.public_key,
"main.py
",-from evmoswallet import Wallet,+            self.public_key = keys[-1].public_key.compressed_bytes
"main.py
",-,+version = 1.0.1
"main.py
",-seed = (,+    assert wallet.public_key == b'\x022-\xe1\xff\xb8\x8f\xb0 \x843_\xcd\x18$\x829\xb5\xf7qi\xbd\xde\x9bq?\x01\xe9\xea\x9eu\xe1b'  # NOQA: E501
"main.py
",-    'report spend crisp crisp world shock morning hour spoon problem one hole program piano donkey width today view canoe clap brick bundle rose book'  # NOQA: E501,
"main.py
",-),
"main.py
",-,
"main.py
",-w = Wallet(seed),
"main.py
",-print(w.eth_address),
"main.py
",-print(w.private_key),
"setup.cfg
",-version = 1.0.0,
,,+.venv
,,+.pytest_cache
,,+__pycache__/
,,+*.py[cod]
,,+*$py.class
,,+.vscode
,,+build
,,+dist
,,+evmoswallet.egg-info
,,+exclude: ^(proto/|evmosproto)
,,+
,,+repos:
,,+  - repo: https://github.com/pre-commit/pre-commit-hooks
,,+    rev: v2.4.0
,,+    hooks:
,,+      - id: trailing-whitespace
,,+      - id: end-of-file-fixer
,,+      - id: check-yaml
,,+      - id: check-added-large-files
,,+        exclude: ^rawdata/
,,+      - id: requirements-txt-fixer
,,+      - id: double-quote-string-fixer
,,+
,,+  - repo: https://gitlab.com/pycqa/flake8
,,+    rev: 3.8.0
,,+    hooks:
,,+      - id: flake8
,,+        additional_dependencies: [flake8-typing-imports==1.6.0]
,,+        exclude: ^alembic/
,,+
,,+  - repo: https://github.com/pre-commit/mirrors-yapf
,,+    rev: v0.31.0
,,+    hooks:
,,+      - id: yapf
,,+
,,+  - repo: https://github.com/asottile/pyupgrade
,,+    rev: v2.4.1
,,+    hooks:
,,+      - id: pyupgrade
,,+        args: [--py36-plus]
,,+
,,+  - repo: https://github.com/asottile/reorder_python_imports
,,+    rev: v2.3.0
,,+    hooks:
,,+      - id: reorder-python-imports
,,+        args: [--py3-plus]
,,+MIT License
,,+
,,+Copyright (c) 2021 Hanchon
,,+
,,"+Permission is hereby granted, free of charge, to any person obtaining a copy"
,,"+of this software and associated documentation files (the ""Software""), to deal"
,,"+in the Software without restriction, including without limitation the rights"
,,"+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"
,,"+copies of the Software, and to permit persons to whom the Software is"
,,"+furnished to do so, subject to the following conditions:"
,,+
,,+The above copyright notice and this permission notice shall be included in all
,,+copies or substantial portions of the Software.
,,+
,,"+THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
,,"+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
,,+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
,,"+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
,,"+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
,,+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
,,+SOFTWARE.
,,+# Evmos wallet
,,+
,,+Evmos wallet utils for python3.
,,+
,,+## Installation
,,+
,,+```sh
,,+pip install evmoswallet
,,+```
,,+
,,+## Usage
,,+
,,+```python
,,+from evmoswallet import Wallet
,,+
,,+wallet = Wallet(seed)
,,+seed = 'report spend crisp crisp world shock morning hour spoon problem one hole program piano donkey width today view canoe clap brick bundle rose book'
,,+
,,"+print(wallet.eth_address) # ""0xe7e3654bc1ea915e7216d8193ef8dd7d5dae987f"""
,,"+print(wallet.evmos_address) # ""evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5"""
,,"+print(wallet.private_key) # bytes.fromhex(""8721109b7244925c0480f4172546b8b53dfe87845274070fbe8e6da739d1b813"")"
,,+
,,+msg = bytes(...) # protobuf message
,,+signed = wallet.sign(msg)
,,+```
,,+
,,+## References
,,+
,,+[pywallet](https://github.com/ranaroussi/pywallet/)
,,+[tow1](https://pypi.org/project/two1/)
,,+import coincurve
,,+from coincurve._libsecp256k1 import ffi
,,+from coincurve._libsecp256k1 import lib
,,+
,,+from evmoswallet.converter import eth_to_evmos
,,+from evmoswallet.eth.ethereum import HDKey
,,+from evmoswallet.eth.ethereum import HDPrivateKey
,,+
,,+
,,+class Wallet:
,,"+    def __init__(self, seed, algo='ethsecp256k1') -> None:"
,,+        if algo == 'ethsecp256k1':
,,+            master_key = HDPrivateKey.master_key_from_mnemonic(seed)
,,"+            root_keys = HDKey.from_path(master_key, ""m/44'/60'/0'"")"
,,+
,,+            acct_priv_key = root_keys[-1]
,,+            # acct_pub_key = acct_priv_key.public_key
,,+
,,+            acct_pub_key = HDKey.from_b58check(acct_priv_key.to_b58check())
,,"+            keys = HDKey.from_path(acct_pub_key, f'{0}/{0}')"
,,+
,,+            self.eth_address = keys[-1].public_key.address()
,,+            self.private_key = bytes.fromhex(keys[-1]._key.to_hex())
,,+            self.evmos_address = eth_to_evmos(self.eth_address)
,,+        else:
,,+            # TODO: sopport for secp256k1
,,+            raise NotImplementedError(f'{algo} is not supported!')
,,+
,,"+    def sign(self, msg: bytes) -> bytes:"
,,+        key = coincurve.PrivateKey(self.private_key)
,,"+        nonce = (lib.secp256k1_nonce_function_rfc6979, ffi.NULL)"
,,"+        return key.sign_recoverable(msg, hasher=None, custom_nonce=nonce)"
,,+import binascii
,,+from typing import Union
,,+
,,+from evmoswallet.converter.bech32 import bech32_decode
,,+from evmoswallet.converter.bech32 import bech32_encode
,,+from evmoswallet.converter.bech32 import convertbits
,,+from evmoswallet.converter.bech32 import Encoding
,,+
,,+EVMOS_PREFIX = 'evmos'
,,+ETH_PREFIX = '0x'
,,+
,,+
,,"+def bech32_to_eth(wallet: str, prefix: str) -> Union[str, None]:"
,,+    decoded = bech32_decode(wallet)
,,+    if decoded[0] != prefix:
,,+        return None
,,"+    words = convertbits(decoded[1], 5, 8, False)"
,,+    res = ''
,,+    for w in words:
,,"+        res = f'{res}{format(w, ""x"")}'"
,,+
,,+    return f'{ETH_PREFIX}{res}'
,,+
,,+
,,"+def eth_to_bech32(wallet: str, prefix: str) -> str:"
,,+    splitted = wallet.split('0x')
,,+    if len(splitted) == 2:
,,+        raw_address = splitted[1]
,,+    else:
,,+        raw_address = wallet
,,+    try:
,,+        array = binascii.unhexlify(raw_address)
,,+        words = [x for x in array]
,,"+        bech32_words = convertbits(words, 8, 5)"
,,"+        bech32_address = bech32_encode(prefix, bech32_words, Encoding.BECH32)"
,,+    except Exception:
,,+        return None
,,+    if len(bech32_address) != 44:
,,+        return None
,,+
,,+    return bech32_address
,,+
,,+
,,"+def evmos_to_eth(wallet: str) -> Union[str, None]:"
,,"+    return bech32_to_eth(wallet, EVMOS_PREFIX)"
,,+
,,+
,,+def eth_to_evmos(wallet: str) -> str:
,,"+    return eth_to_bech32(wallet, EVMOS_PREFIX)"
,,"+# Copyright (c) 2017, 2020 Pieter Wuille"
,,+#
,,"+# Permission is hereby granted, free of charge, to any person obtaining a copy"
,,"+# of this software and associated documentation files (the ""Software""), to deal"
,,"+# in the Software without restriction, including without limitation the rights"
,,"+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"
,,"+# copies of the Software, and to permit persons to whom the Software is"
,,"+# furnished to do so, subject to the following conditions:"
,,+#
,,+# The above copyright notice and this permission notice shall be included in
,,+# all copies or substantial portions of the Software.
,,+#
,,"+# THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"
,,"+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"
,,+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
,,"+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"
,,"+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"
,,+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
,,+# THE SOFTWARE.
,,"+""""""Reference implementation for Bech32/Bech32m and segwit addresses."""""""
,,+from enum import Enum
,,+
,,+
,,+class Encoding(Enum):
,,"+    """"""Enumeration type to list the various supported encodings."""""""
,,+    BECH32 = 1
,,+    BECH32M = 2
,,+
,,+
,,+CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'
,,+BECH32M_CONST = 0x2bc830a3
,,+
,,+
,,+def bech32_polymod(values):
,,"+    """"""Internal function that computes the Bech32 checksum."""""""
,,"+    generator = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]"
,,+    chk = 1
,,+    for value in values:
,,+        top = chk >> 25
,,+        chk = (chk & 0x1ffffff) << 5 ^ value
,,+        for i in range(5):
,,+            chk ^= generator[i] if ((top >> i) & 1) else 0
,,+    return chk
,,+
,,+
,,+def bech32_hrp_expand(hrp):
,,"+    """"""Expand the HRP into values for checksum computation."""""""
,,+    return [ord(x) >> 5 for x in hrp] + [0] + [ord(x) & 31 for x in hrp]
,,+
,,+
,,"+def bech32_verify_checksum(hrp, data):"
,,"+    """"""Verify a checksum given HRP and converted data characters."""""""
,,+    const = bech32_polymod(bech32_hrp_expand(hrp) + data)
,,+    if const == 1:
,,+        return Encoding.BECH32
,,+    if const == BECH32M_CONST:
,,+        return Encoding.BECH32M
,,+    return None
,,+
,,+
,,"+def bech32_create_checksum(hrp, data, spec):"
,,"+    """"""Compute the checksum values given HRP and data."""""""
,,+    values = bech32_hrp_expand(hrp) + data
,,+    const = BECH32M_CONST if spec == Encoding.BECH32M else 1
,,"+    polymod = bech32_polymod(values + [0, 0, 0, 0, 0, 0]) ^ const"
,,+    return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]
,,+
,,+
,,"+def bech32_encode(hrp, data, spec):"
,,"+    """"""Compute a Bech32 string given HRP and data values."""""""
,,"+    combined = data + bech32_create_checksum(hrp, data, spec)"
,,+    return hrp + '1' + ''.join([CHARSET[d] for d in combined])
,,+
,,+
,,+def bech32_decode(bech):
,,"+    """"""Validate a Bech32/Bech32m string, and determine HRP and data."""""""
,,+    if ((any(ord(x) < 33 or ord(x) > 126 for x in bech)) or (bech.lower() != bech and bech.upper() != bech)):
,,"+        return (None, None, None)"
,,+    bech = bech.lower()
,,+    pos = bech.rfind('1')
,,+    if pos < 1 or pos + 7 > len(bech) or len(bech) > 90:
,,"+        return (None, None, None)"
,,+    if not all(x in CHARSET for x in bech[pos + 1:]):
,,"+        return (None, None, None)"
,,+    hrp = bech[:pos]
,,+    data = [CHARSET.find(x) for x in bech[pos + 1:]]
,,"+    spec = bech32_verify_checksum(hrp, data)"
,,+    if spec is None:
,,"+        return (None, None, None)"
,,"+    return (hrp, data[:-6], spec)"
,,+
,,+
,,"+def convertbits(data, frombits, tobits, pad=True):"
,,"+    """"""General power-of-2 base conversion."""""""
,,+    acc = 0
,,+    bits = 0
,,+    ret = []
,,+    maxv = (1 << tobits) - 1
,,+    max_acc = (1 << (frombits + tobits - 1)) - 1
,,+    for value in data:
,,+        if value < 0 or (value >> frombits):
,,+            return None
,,+        acc = ((acc << frombits) | value) & max_acc
,,+        bits += frombits
,,+        while bits >= tobits:
,,+            bits -= tobits
,,+            ret.append((acc >> bits) & maxv)
,,+    if pad:
,,+        if bits:
,,+            ret.append((acc << (tobits - bits)) & maxv)
,,+    elif bits >= frombits or ((acc << (tobits - bits)) & maxv):
,,+        return None
,,+    return ret
,,+
,,+
,,"+def decode(hrp, addr):"
,,"+    """"""Decode a segwit address."""""""
,,"+    hrpgot, data, spec = bech32_decode(addr)"
,,+    if hrpgot != hrp:
,,"+        return (None, None)"
,,"+    decoded = convertbits(data[1:], 5, 8, False)"
,,+    if decoded is None or len(decoded) < 2 or len(decoded) > 40:
,,"+        return (None, None)"
,,+    if data[0] > 16:
,,"+        return (None, None)"
,,+    if data[0] == 0 and len(decoded) != 20 and len(decoded) != 32:
,,"+        return (None, None)"
,,+    if data[0] == 0 and spec != Encoding.BECH32 or data[0] != 0 and spec != Encoding.BECH32M:
,,"+        return (None, None)"
,,"+    return (data[0], decoded)"
,,+
,,+
,,"+def encode(hrp, witver, witprog):"
,,"+    """"""Encode a segwit address."""""""
,,+    spec = Encoding.BECH32 if witver == 0 else Encoding.BECH32M
,,"+    ret = bech32_encode(hrp, [witver] + convertbits(witprog, 8, 5), spec)"
,,"+    if decode(hrp, ret) == (None, None):"
,,+        return None
,,+    return ret
,,+# Crypto utils
,,+
,,+## Reference
,,+
,,+- [two1](https://pypi.org/project/two1/)
,,+from evmoswallet.crypto.ecdsa import ECPointAffine  # NOQA: F401
,,+from evmoswallet.crypto.ecdsa import EllipticCurve  # NOQA: F401
,,+from evmoswallet.crypto.ecdsa import secp256k1  # NOQA: F401
,,+try:
,,+    from evmoswallet.crypto import ecdsa_openssl as _ecdsa
,,+except Exception:
,,+    from evmoswallet.crypto import ecdsa_python as _ecdsa
,,+
,,+ECPointAffine = _ecdsa.ECPointAffine
,,+EllipticCurve = _ecdsa.EllipticCurve
,,+secp256k1 = _ecdsa.secp256k1
,,+import hmac
,,+import random
,,+from collections import namedtuple
,,+
,,"+Point = namedtuple('Point', ['x', 'y'])"
,,+
,,+
,,+class EllipticCurveBase:
,,"+    """""" A generic class for elliptic curves and operations on them."
,,+
,,+        The curves must be of the form: y^2 = x^3 + a*x + b.
,,"+    """""""
,,"+    def __init__(self, hash_function):"
,,+        self.hash_function = hash_function
,,+
,,"+    def is_on_curve(self, p):"
,,"+        """""" Checks whether a point is on the curve."
,,+
,,+        Args:
,,+            p (ECPointAffine): Point to be checked
,,+
,,+        Returns:
,,"+            bool: True if p is on the curve, False otherwise."
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def y_from_x(self, x):"
,,"+        """""" Computes the y component corresponding to x."
,,+
,,"+            Since elliptic curves are symmetric about the x-axis,"
,,+            the x component (and sign) is all that is required to determine
,,+            a point on the curve.
,,+
,,+        Args:
,,+            x (int): x component of the point.
,,+
,,+        Returns:
,,+            tuple: both possible y components of the point.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def gen_key_pair(self, random_generator=random.SystemRandom()):"
,,"+        """""" Generates a public/private key pair."
,,+
,,+        Args:
,,+            random_generator (generator): The random generator to use.
,,+        Returns:
,,+            tuple: A private key in the range of 1 to `self.n - 1`
,,+               and an ECPointAffine containing the public key point.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def public_key(self, private_key):"
,,"+        """""" Returns the public (verifying) key for a given private key."
,,+
,,+        Args:
,,+            private_key (int): the private key to derive the public key for.
,,+
,,+        Returns:
,,+            ECPointAffine: The point representing the public key.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def recover_public_key(self, message, signature, recovery_id=None):"
,,"+        """""" Recovers possibilities for the public key associated with the"
,,+            private key used to sign message and generate signature.
,,+
,,+            Since there are multiple possibilities (two for curves with
,,"+            co-factor = 1), each possibility that successfully verifies the"
,,+            signature is returned.
,,+        Args:
,,+           message (bytes): The message that was signed.
,,+           signature (ECPointAffine): The point representing the signature.
,,"+           recovery_id (int) (Optional): If provided, limits the valid x and y"
,,+              point to only that described by the recovery_id.
,,+
,,+        Returns:
,,+           list(ECPointAffine): List of points representing valid public
,,+              keys that verify signature.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def _sign(self, message, private_key, do_hash=True, secret=None):"
,,+        raise NotImplementedError
,,+
,,"+    def sign(self, message, private_key, do_hash=True):"
,,"+        """""" Signs a message with the given private key."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed
,,+            private_key (int): Integer that is the private key
,,+            do_hash (bool): True if the message should be hashed prior
,,"+                to signing, False if not. This should always be left as"
,,+                True except in special situations which require doing
,,+                the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            (Point, int): The point (r, s) representing the signature"
,,+                and the ID representing which public key possibility
,,+                is associated with the private key being used to sign.
,,"+        """""""
,,"+        return self._sign(message, private_key, do_hash)"
,,+
,,"+    def verify(self, message, signature, public_key, do_hash=True):"
,,"+        """""" Verifies that signature was generated with a private key corresponding"
,,"+            to public key, operating on message."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed
,,"+            signature (Point): (r, s) representing the signature"
,,+            public_key (ECPointAffine): ECPointAffine of the public key
,,+            do_hash (bool): True if the message should be hashed prior
,,"+               to signing, False if not. This should always be left as"
,,+               True except in special situations which require doing
,,+               the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            bool: True if the signature is verified, False otherwise."
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,+    def _nonce_random(self):
,,"+        return random.SystemRandom().randrange(1, self.n - 1)"
,,+
,,"+    def _nonce_rfc6979(self, private_key, message):"
,,"+        """""" Computes a deterministic nonce (k) for use when signing"
,,"+            according to RFC6979 (https://tools.ietf.org/html/rfc6979),"
,,+            Section 3.2.
,,+
,,+        Args:
,,+            private_key (int): The private key.
,,+            message (bytes): A hash of the input message.
,,+
,,+        Returns:
,,+            int: A deterministic nonce.
,,"+        """""""
,,+        hash_bytes = 32
,,"+        x = private_key.to_bytes(hash_bytes, 'big')"
,,"+        # Message should already be hashed by the time it gets here,"
,,+        # so don't bother doing another hash.
,,+        x_msg = x + message
,,+
,,+        # Step b
,,+        V = bytes([0x1] * hash_bytes)
,,+
,,+        # Step c
,,+        K = bytes([0x0] * hash_bytes)
,,+
,,+        # Step d
,,"+        K = hmac.new(K, V + bytes([0]) + x_msg, self.hash_function).digest()"
,,+
,,+        # Step e
,,"+        V = hmac.new(K, V, self.hash_function).digest()"
,,+
,,+        # Step f
,,"+        K = hmac.new(K, V + bytes([0x1]) + x_msg, self.hash_function).digest()"
,,+
,,+        # Step g
,,"+        V = hmac.new(K, V, self.hash_function).digest()"
,,+
,,+        while True:
,,+            # Step h.1
,,+            T = bytes()
,,+
,,+            # Step h.2
,,+            while 8 * len(T) < self.nlen:
,,"+                V = hmac.new(K, V, self.hash_function).digest()"
,,+                T += V
,,+
,,+            # Step h.3
,,"+            k = int.from_bytes(T, 'big')"
,,+            if k >= 1 and k < (self.n - 1):
,,+                return k
,,+
,,"+            K = hmac.new(K, V + bytes([0]), self.hash_function).digest()"
,,"+            V = hmac.new(K, V, self.hash_function).digest()"
,,+import hashlib
,,+import math
,,+import random
,,+from ctypes import c_char_p
,,+from ctypes import c_void_p
,,+from ctypes import create_string_buffer
,,+
,,+from evmoswallet.crypto import openssl as ossl
,,+from evmoswallet.crypto.ecdsa_base import EllipticCurveBase
,,+from evmoswallet.crypto.ecdsa_base import Point
,,+
,,+
,,+class ECPointAffine:
,,"+    """""" An affine (2D) representation of an elliptic curve point."
,,+
,,"+    In this implementation, only the minimum functionality"
,,+    required for bitcoin crypto-API compatibility is provided.
,,+    All math operations make use of OpenSSL primitives.
,,+
,,+    Args:
,,+        curve (EllipticCurve): The curve the point is on.
,,+        x (int): x component of point.
,,+        y (int): y component of point.
,,+        infinity (bool): Whether or not this point is at infinity.
,,+
,,+    Returns:
,,"+        ECPointAffine: the point formed by (x, y) on curve."
,,"+    """""""
,,"+    def __init__(self, curve, x, y, infinity=False):"
,,+        self.x = x
,,+        self.y = y
,,+        self.curve = curve
,,+        self.infinity = infinity
,,+
,,+    def __str__(self):
,,"+        return f'(0x{self.x:x}, 0x{self.y:x})'"
,,+
,,"+    def __eq__(self, b):"
,,+        return ((self.x == b.x) and (self.y == b.y)) or \
,,+            (self.infinity and b.infinity)
,,+
,,"+    def __add__(self, b):"
,,+        assert self.curve == b.curve
,,+
,,"+        a_pt = ossl.point_new_from_ints(self.curve.os_group, self.x, self.y, self.infinity)"
,,"+        b_pt = ossl.point_new_from_ints(b.curve.os_group, b.x, b.y, b.infinity)"
,,"+        ossl.lc.EC_POINT_add(self.curve.os_group, a_pt, a_pt, b_pt, None)"
,,+
,,"+        x, y, inf = ossl.point_get_xy_ints(self.curve.os_group, a_pt)"
,,+
,,+        ossl.lc.EC_POINT_free(a_pt)
,,+        ossl.lc.EC_POINT_free(b_pt)
,,+
,,"+        return ECPointAffine(self.curve, x, y, inf)"
,,+
,,+    @property
,,+    def compressed_bytes(self):
,,"+        """""" Returns the compressed bytes for this point."
,,+
,,"+        If pt.y is odd, 0x03 is pre-pended to pt.x."
,,"+        If pt.y is even, 0x02 is pre-pended to pt.x."
,,+
,,+        Returns:
,,+            bytes: Compressed byte representation.
,,"+        """""""
,,+        nbytes = math.ceil(self.curve.nlen / 8)
,,"+        return bytes([(self.y & 0x1) + 0x02]) + self.x.to_bytes(nbytes, 'big')"
,,+
,,+    def __bytes__(self):
,,"+        """""" Returns the full-uncompressed point"
,,"+        """""""
,,+        nbytes = math.ceil(self.curve.nlen / 8)
,,"+        return bytes([0x04]) + self.x.to_bytes(nbytes, 'big') + self.y.to_bytes(nbytes, 'big')"
,,+
,,+
,,+class EllipticCurve(EllipticCurveBase):
,,"+    """""" A generic class for elliptic curves and operations on them."
,,+
,,+    The curves must be of the form: y^2 = x^3 + a*x + b.
,,+
,,+    Args:
,,+        hash_function (function): The function to use for hashing messages.
,,"+    """""""
,,+    curve_name = None
,,+
,,"+    def __init__(self, hash_function):"
,,+        super().__init__(hash_function)
,,+        self.os_group = c_void_p(ossl.lc.EC_GROUP_new_by_curve_name(self.curve_name))
,,+
,,+        params = ossl.get_curve_params(self.os_group)
,,+
,,+        self.p = params['p']
,,+        self.a = params['a']
,,+        self.b = params['b']
,,+        self.n = params['n']
,,+        self.h = params['h']
,,+
,,+        self.nlen = self.n.bit_length()
,,+        self.plen = self.p.bit_length()
,,+
,,+        # We keep a pointer to the libcrypto CDLL object so that
,,+        # it is guaranteed to be around when __del__ is called. If
,,"+        # we don't, a race condition exists whereby if the garbage"
,,"+        # collector disposes of ossl.lc before this object, we won't"
,,+        # be able to free self.os_group (in __del__).
,,+        self._lc = ossl.lc
,,+
,,+    def __del__(self):
,,+        self._lc.EC_GROUP_free(self.os_group)
,,+
,,"+    def is_on_curve(self, p):"
,,"+        """""" Checks whether a point is on the curve."
,,+
,,+        Args:
,,+            p (ECPointAffine): Point to be checked
,,+
,,+        Returns:
,,"+            bool: True if p is on the curve, False otherwise."
,,"+        """""""
,,"+        ec_pt = ossl.point_new_from_ints(self.os_group, p.x, p.y)"
,,"+        on_curve = ossl.lc.EC_POINT_is_on_curve(self.os_group, ec_pt, None)"
,,+        ossl.lc.EC_POINT_free(ec_pt)
,,+
,,+        return bool(on_curve)
,,+
,,"+    def y_from_x(self, x):"
,,"+        """""" Computes the y component corresponding to x."
,,+
,,"+        Since elliptic curves are symmetric about the x-axis,"
,,+        the x component (and sign) is all that is required to determine
,,+        a point on the curve.
,,+
,,+        Args:
,,+            x (int): x component of the point.
,,+
,,+        Returns:
,,+            tuple: both possible y components of the point.
,,"+        """""""
,,+        rv = []
,,+        x_bn = ossl.int_to_bn(x)
,,"+        for y_bit in [0, 1]:"
,,+            # Create a new point
,,+            ec_pt = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,"+            ossl.lc.EC_POINT_set_compressed_coordinates_GFp(self.os_group, ec_pt, x_bn, y_bit, c_void_p())"
,,+
,,"+            on_curve = ossl.lc.EC_POINT_is_on_curve(self.os_group, ec_pt, c_void_p())"
,,+            if not on_curve:
,,+                ossl.lc.EC_POINT_free(ec_pt)
,,+                rv.append(None)
,,+                continue
,,+
,,+            # Get the y value
,,"+            _, y, _ = ossl.point_get_xy_ints(self.os_group, ec_pt)"
,,+            rv.append(y)
,,+            ossl.lc.EC_POINT_free(ec_pt)
,,+
,,+        ossl.lc.BN_free(x_bn)
,,+
,,+        return rv
,,+
,,"+    def gen_key_pair(self, random_generator=random.SystemRandom()):"
,,"+        """""" Generates a public/private key pair."
,,+
,,+        Args:
,,+            random_generator (generator): The random generator to use.
,,+
,,+        Returns:
,,+            tuple:
,,+                A private key in the range of 1 to `self.n - 1`
,,+                and an ECPointAffine containing the public key point.
,,"+        """""""
,,"+        private = random_generator.randrange(1, self.n)"
,,"+        return private, self.public_key(private)"
,,+
,,"+    def public_key(self, private_key):"
,,"+        """""" Returns the public (verifying) key for a given private key."
,,+
,,+        Args:
,,+            private_key (int): the private key to derive the public key for.
,,+
,,+        Returns:
,,+            ECPointAffine: The point representing the public key.
,,"+        """""""
,,"+        k = ossl.new_key(self.curve_name, private_key)"
,,"+        pub_x, pub_y, is_inf = ossl.get_public_key_ints(k)"
,,+        ossl.lc.EC_KEY_free(k)
,,"+        return ECPointAffine(self, pub_x, pub_y, is_inf)"
,,+
,,"+    def recover_public_key(self, message, signature, recovery_id=None):"
,,"+        """""" Recovers possibilities for the public key associated with the"
,,+        private key used to sign message and generate signature.
,,+
,,+        Since there are multiple possibilities (two for curves with
,,"+        co-factor = 1), each possibility that successfully verifies the"
,,+        signature is returned.
,,+
,,+        Args:
,,+           message (bytes): The message that was signed.
,,+           signature (ECPointAffine): The point representing the signature.
,,"+           recovery_id (int) (Optional): If provided, limits the valid x and y"
,,+              point to only that described by the recovery_id.
,,+
,,+        Returns:
,,+           list(ECPointAffine): List of points representing valid public
,,+           keys that verify signature.
,,"+        """""""
,,+        r = signature.x
,,+        s = signature.y
,,+
,,+        ctx = c_void_p(ossl.lc.BN_CTX_new())
,,+        ossl.lc.BN_CTX_start(ctx)
,,+
,,+        order_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        x_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        i_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        in_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        p_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        r_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        s_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        rinv_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        z_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,"+        ossl.lc.EC_GROUP_get_order(self.os_group, order_bn, ctx)"
,,+
,,"+        ossl.int_to_bn(self.p, p_bn)"
,,"+        ossl.int_to_bn(r, r_bn)"
,,"+        ossl.int_to_bn(s, s_bn)"
,,"+        ossl.lc.BN_mod_inverse(rinv_bn, r_bn, order_bn, ctx)"
,,+
,,+        if recovery_id is not None:
,,+            i_list = [recovery_id >> 1]
,,+            k_list = [recovery_id & 0x1]
,,+        else:
,,+            i_list = range(2)
,,+            k_list = range(2)
,,+
,,+        rv = []
,,+        num_bytes = math.ceil(self.nlen / 8)
,,+
,,"+        z = int.from_bytes(self.hash_function(message).digest()[:num_bytes], 'big')"
,,"+        ossl.int_to_bn(z, z_bn)"
,,+
,,+        zG = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,+        sR = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,+        temp = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,+        pub_key = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,+        Rn = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,+
,,+        for i in i_list:
,,"+            ossl.int_to_bn(i, i_bn)"
,,"+            ossl.lc.BN_mod_mul(in_bn, i_bn, order_bn, p_bn, ctx)"
,,"+            ossl.lc.BN_mod_add(x_bn, r_bn, in_bn, p_bn, ctx)"
,,+            x = ossl.bn_to_int(x_bn)
,,+            ys = self.y_from_x(x)
,,+
,,+            for k in k_list:
,,+                y = ys[k]
,,+                if y & 0x1 != k:
,,+                    y = ys[k ^ 1]
,,+
,,"+                R = ossl.point_new_from_ints(self.os_group, r, y)"
,,"+                ossl.lc.EC_POINT_mul(self.os_group, Rn, None, R, order_bn, ctx)"
,,"+                if not ossl.lc.EC_POINT_is_at_infinity(self.os_group, Rn):"
,,+                    continue
,,+
,,"+                ossl.lc.EC_POINT_mul(self.os_group, zG, z_bn, None, None, ctx)"
,,"+                ossl.lc.EC_POINT_invert(self.os_group, zG, ctx)"
,,"+                ossl.lc.EC_POINT_mul(self.os_group, sR, None, R, s_bn, ctx)"
,,"+                ossl.lc.EC_POINT_add(self.os_group, temp, sR, zG, ctx)"
,,"+                ossl.lc.EC_POINT_mul(self.os_group, pub_key, None, temp, rinv_bn, ctx)"
,,+
,,+                ossl.lc.EC_POINT_free(R)
,,+
,,+                # Convert to ECPointAffine
,,"+                pub_x, pub_y, inf = ossl.point_get_xy_ints(self.os_group, pub_key)"
,,"+                rv.append((ECPointAffine(self, pub_x, pub_y, inf), 2 * i + k))"
,,+
,,+        ossl.lc.EC_POINT_free(zG)
,,+        ossl.lc.EC_POINT_free(sR)
,,+        ossl.lc.EC_POINT_free(temp)
,,+        ossl.lc.EC_POINT_free(pub_key)
,,+        ossl.lc.EC_POINT_free(Rn)
,,+
,,+        ossl.lc.BN_CTX_end(ctx)
,,+        ossl.lc.BN_CTX_free(ctx)
,,+
,,+        return rv
,,+
,,"+    def _sign(self, message, private_key, do_hash=True, secret=None):"
,,"+        # This function computes k, kinv and rp before sending into"
,,+        # OpenSSL ECDSA_do_sign_ex() rather than using ECDSA_do_sign()
,,+        # directly. The reason for this is that as of the commit that
,,"+        # introduces this comment, OpenSSL only supports deterministic"
,,+        # signing nonces (RFC6979) in the master branch and not any
,,"+        # release. As a result, we cannot depend on callers having any"
,,+        # OpenSSL version capable of RFC6979 deterministic nonces.
,,"+        # Nevertheless, computation of kinv (from k) and rp is done"
,,+        # using OpenSSL primitives.
,,+        ossl.lc.ERR_clear_error()
,,+
,,+        hashed = self.hash_function(message).digest() if do_hash else message
,,+
,,+        r = 0
,,+        s = 0
,,+        recovery_id = 0
,,+
,,"+        key = ossl.new_key(self.curve_name, private_key)"
,,+
,,+        ctx = c_void_p(ossl.lc.BN_CTX_new())
,,+        ossl.lc.BN_CTX_start(ctx)
,,+
,,+        order_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        k_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        kinv_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        px_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,+        r_bn = c_void_p(ossl.lc.BN_CTX_get(ctx))
,,"+        ossl.lc.EC_GROUP_get_order(self.os_group, order_bn, ctx)"
,,+
,,+        while r == 0 or s == 0:
,,"+            k = self._nonce_rfc6979(private_key, hashed) if secret is None else secret"
,,"+            ossl.int_to_bn(k, k_bn)"
,,+
,,"+            ossl.lc.BN_mod_inverse(kinv_bn, k_bn, order_bn, ctx)"
,,+
,,+            p = c_void_p(ossl.lc.EC_POINT_new(self.os_group))
,,"+            ossl.lc.EC_POINT_mul(self.os_group, p, k_bn, c_void_p(), c_void_p(), ctx)"
,,+            assert self.h == 1
,,+
,,"+            px, py, _ = ossl.point_get_xy_ints(self.os_group, p)"
,,+            recovery_id = 2 if px > self.n else 0
,,+            recovery_id |= (py & 0x1)
,,+
,,+            # Get r
,,"+            ossl.int_to_bn(px, px_bn)"
,,"+            ossl.lc.BN_nnmod(r_bn, px_bn, order_bn, ctx)"
,,+            r = ossl.bn_to_int(r_bn)
,,+
,,+            if r == 0:
,,+                continue
,,+
,,+            hashed_buf = c_char_p(hashed)
,,"+            sig = ossl.lc.ECDSA_do_sign_ex(hashed_buf, len(hashed), kinv_bn, r_bn, key)"
,,+            err = ossl.lc.ERR_peek_error()
,,+            if err:
,,+                err_buf = create_string_buffer(120)
,,"+                ossl.lc.ERR_error_string(err, err_buf)"
,,+                raise Exception('Problem when signing: %s' % err_buf.raw.decode())
,,+
,,+            sig_r = ossl.bn_to_int(sig.contents.r)
,,+            sig_s = ossl.bn_to_int(sig.contents.s)
,,+
,,+            if sig_r != r:
,,"+                raise ValueError(""Didn't get the same r value."")"
,,+            s = sig_s
,,+
,,+        ossl.lc.EC_KEY_free(key)
,,+        ossl.lc.BN_CTX_end(ctx)
,,+        ossl.lc.BN_CTX_free(ctx)
,,+
,,"+        return (Point(r, s), recovery_id)"
,,+
,,"+    def verify(self, message, signature, public_key, do_hash=True):"
,,"+        """""" Verifies that signature was generated with a private key corresponding"
,,"+        to public key, operating on message."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed
,,"+            signature (Point): (r, s) representing the signature"
,,+            public_key (ECPointAffine): ECPointAffine of the public key
,,+            do_hash (bool): True if the message should be hashed prior
,,"+               to signing, False if not. This should always be left as"
,,+               True except in special situations which require doing
,,+               the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            bool: True if the signature is verified, False otherwise."
,,"+        """""""
,,+        r = signature.x
,,+        s = signature.y
,,+
,,"+        sig = ossl.sig_new_from_ints(r, s)"
,,+
,,+        hashed = self.hash_function(message).digest() if do_hash else message
,,+
,,+        key = c_void_p(ossl.lc.EC_KEY_new_by_curve_name(self.curve_name))
,,"+        ossl.set_public_key_from_ints(key=key, x=public_key.x, y=public_key.y, infinity=public_key.infinity)"
,,+
,,+        dig_buf = create_string_buffer(hashed)
,,"+        verified = ossl.lc.ECDSA_do_verify(dig_buf, len(hashed), sig, key)"
,,+
,,+        ossl.lc.ECDSA_SIG_free(sig)
,,+        ossl.lc.EC_KEY_free(key)
,,+
,,+        return bool(verified)
,,+
,,+
,,+class p256(EllipticCurve):
,,+    curve_name = ossl.lc.OBJ_sn2nid(c_char_p(b'prime256v1'))
,,+
,,+    def __init__(self):
,,+        super().__init__(hashlib.sha256)
,,+
,,+
,,+class secp256k1(EllipticCurve):
,,+    curve_name = ossl.lc.OBJ_sn2nid(c_char_p(b'secp256k1'))
,,+
,,+    def __init__(self):
,,+        super().__init__(hashlib.sha256)
,,+import hashlib
,,+import math
,,+import random
,,+from collections import namedtuple
,,+
,,+from evmoswallet.crypto.ecdsa_base import EllipticCurveBase
,,+
,,+# Links
,,+# https://en.wikibooks.org/wiki/Cryptography/Elliptic_curve
,,+# https://en.bitcoin.it/wiki/Secp256k1
,,+# https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm
,,+# http://www.coindesk.com/math-behind-bitcoin/
,,+# https://bitcointalk.org/index.php?topic=289795.120
,,"+"""""" This module is intended to provide straight-forward ECDSA"
,,+    capability in a pure Python module. It provides group addition and
,,+    multiplication using either Affine or Jacobian coordinates and
,,+    makes use of constant- time operations to prevent against (simple)
,,+    side-channel attacks.
,,+
,,"+    It does not make use of blinding techniques, prevent against"
,,"+    certain kinds of cache attacks, differential side-channel attacks,"
,,"+    etc. For those requiring a more secure implementation, use:"
,,+    https://github.com/dstufft/pynacl.
,,"+"""""""
,,+
,,"+Point = namedtuple('Point', ['x', 'y'])"
,,+
,,+
,,"+def montgomery_ladder(k, p):"
,,"+    """""" Implements scalar multiplication via the Montgomery ladder"
,,+    technique.
,,+
,,+    This technique is used to prevent against simple side-channel
,,+    attacks as well as certain kinds of cache attacks.
,,+
,,+    Args:
,,+        k (int): The scalar to multiply by.
,,+        p (ECPoint): The point to multiply by k.
,,+
,,+    Returns:
,,+        ECPoint: p * k
,,"+    """""""
,,"+    if isinstance(p, ECPointAffine):"
,,"+        r0 = ECPointAffine(p.curve, 0, 0, True)"
,,"+    elif isinstance(p, ECPointJacobian):"
,,"+        r0 = ECPointJacobian(p.curve, 0, 0, 0, True)"
,,+    else:
,,+        raise TypeError('p is not an ECPoint!')
,,+
,,"+    r = [r0, p]"
,,+
,,+    # Use only arithmetic operations to decide which result goes
,,+    # where. Using branches (if/else) can lead to M-fault and cache
,,+    # flush+reload attacks.
,,+    for i in reversed(range(k.bit_length())):
,,+        di = (k >> i) & 0x1
,,+        r[(di + 1) % 2] = r[0] + r[1]
,,+        r[di] = r[di].double()
,,+
,,+    return r[0]
,,+
,,+
,,+class ECPoint:
,,"+    """""" Base class for any elliptic curve point implementations."
,,+
,,+    Currently there are two implementations provided: 1)
,,"+    ECPointAffine which is the standard affine coordinate system,"
,,+    and 2) ECPointJacobian which is a 3-dimensional projected
,,+    coordinate system.
,,+
,,+    The EllipticCurve class currently utilizes ECPointJacobian for
,,"+    efficiency reasons. However, switching to the affine"
,,+    implementation is trivial.
,,+
,,+    Args:
,,+        curve (EllipticCurve): The curve the point is on.
,,+        x (int): x component of point.
,,+        y (int): y component of point.
,,+        z (int) (Optional): z component of point (only used in Jacobian)
,,+        infinity (bool) (Optional): Whether this is the point-at-infinity.
,,+
,,+    Returns:
,,"+        ECPoint: the point formed by (x, y, z) on curve."
,,"+    """""""
,,+    @staticmethod
,,+    def from_affine():
,,"+        """""" Converts from an Affine representation to a Jacobian."
,,"+        """""""
,,+        raise NotImplementedError()
,,+
,,+    def from_jacobian():
,,"+        """""" Converts from a Jacobian representation to an Affine."
,,"+        """""""
,,+        raise NotImplementedError()
,,+
,,"+    def __init__(self, curve, x, y, z=0, infinity=False):"
,,+        self.x = x
,,+        self.y = y
,,+        self.z = z
,,+        self.curve = curve
,,+        self.infinity = infinity
,,+
,,+    def __str__(self):
,,+        raise NotImplementedError()
,,+
,,"+    def __eq__(self, b):"
,,+        return ((self.x == b.x) and (self.y == b.y) and (self.z == b.z)) or (self.infinity and b.infinity)
,,+
,,"+    def __add__(self, b):"
,,+        raise NotImplementedError()
,,+
,,"+    def __sub__(self, b):"
,,+        raise NotImplementedError()
,,+
,,"+    def __mul__(self, k):"
,,+        raise NotImplementedError()
,,+
,,+    def double(self):
,,"+        """""" Implements a doubling of this point (i.e. 2P)"
,,"+        """""""
,,+        raise NotImplementedError()
,,+
,,+    def to_affine(self):
,,"+        """""" If not affine, converts to affine. Otherwise should return `self`."
,,"+        """""""
,,+        raise NotImplementedError()
,,+
,,+    def to_jacobian(self):
,,"+        """""" If not affine, converts to affine. Otherwise should return `self`."
,,"+        """""""
,,+        raise NotImplementedError()
,,+
,,+
,,+class ECPointJacobian(ECPoint):
,,"+    """""" Encapsulates a point on an elliptic curve."
,,+
,,+    This class provides a Jacobian representation of a point
,,+    on an elliptic curve. It presents the standard addition and
,,+    scalar multiplication operations between two points as overloaded
,,+    '+' and '*' Python operators. Scalar multiplications are computed
,,+    via the Montgomery Ladder technique (same as OpenSSL).
,,+
,,+    All math operations from:
,,+    https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates
,,+
,,+    Args:
,,+        curve (EllipticCurve): The curve the point is on.
,,+        x (int): x component of point.
,,+        y (int): y component of point.
,,+        z (int): z component of point.
,,+        infinity (bool) (Optional): Whether this is the point-at-infinity.
,,+
,,+    Returns:
,,"+        ECPointAffine: the point formed by (x, y) on curve."
,,"+    """""""
,,+    @staticmethod
,,+    def from_affine(affine_point):
,,"+        """""" Converts from an affine point to a Jacobian representation."
,,+        This is simplisticly done by using `Z = 1`.
,,+
,,+        Args:
,,+            affine_point (ECPointAffine): The affine point to convert.
,,+
,,+        Returns:
,,+            ECPointJacobian: The jacobian representation.
,,"+        """""""
,,+        return affine_point.to_jacobian()
,,+
,,+    @staticmethod
,,+    def from_jacobian(jacobian_point):
,,"+        """""" A no-op since the point is already jacobian."
,,+
,,+        Args:
,,+            jacobian_point (ECPointJacobian): A Jacobian point
,,+
,,+        Returns:
,,+            ECPointJacobian: Returns the input arg.
,,"+        """""""
,,+        return jacobian_point
,,+
,,+    @staticmethod
,,"+    def from_int(curve, i):"
,,"+        """""" Creates a point from an integer."
,,+
,,+        Assumes that pt.y is the lower bits of i and pt.x is
,,+        the upper bits of i.
,,+
,,+        Args:
,,+            curve (EllipticCurve): The curve to which the point belongs.
,,+            i (int): integer representing the point.
,,+
,,+        Returns:
,,+            ECPointJacobian: point on curve.
,,"+        """""""
,,"+        return ECPointAffine.from_int(curve, i).to_jacobian()"
,,+
,,"+    def __init__(self, curve, x, y, z, infinity=False):"
,,+        if z == 0 or infinity:
,,"+            super().__init__(curve, 0, 1, 0, True)"
,,+        else:
,,"+            super().__init__(curve, x, y, z, infinity)"
,,+
,,"+        self.z2 = pow(self.z, 2, self.curve.p)"
,,+        self.z3 = (self.z2 * self.z) % self.curve.p
,,+
,,+    def __str__(self):
,,"+        return 'O' if self.infinity else '(%d, %d, %d)' % (self.x, self.y, self.z)"
,,+
,,"+    def __add__(self, b):"
,,+        assert self.curve == b.curve
,,+
,,"+        if not isinstance(b, ECPointJacobian):"
,,+            raise TypeError('b must be an ECPointJacobian object')
,,+
,,+        if self.infinity:
,,+            return b
,,+        if b.infinity:
,,+            return self
,,+
,,+        u1 = (self.x * b.z2) % self.curve.p
,,+        u2 = (b.x * self.z2) % self.curve.p
,,+        s1 = (self.y * b.z3) % self.curve.p
,,+        s2 = (b.y * self.z3) % self.curve.p
,,+
,,+        if u1 == u2:
,,+            if s1 != s2:
,,"+                return ECPointJacobian(self.curve, 0, 0, 0, True)"
,,+            else:
,,+                return self.double()
,,+
,,+        h = u2 - u1
,,+        r = s2 - s1
,,+
,,"+        h2 = pow(h, 2, self.curve.p)"
,,+        h3 = (h2 * h) % self.curve.p
,,+
,,"+        x3 = (pow(r, 2, self.curve.p) - h3 - (2 * u1 * h2)) % self.curve.p"
,,+        y3 = (r * (u1 * h2 - x3) - (s1 * h3)) % self.curve.p
,,+        z3 = (self.z * b.z * h) % self.curve.p
,,+
,,"+        return ECPointJacobian(self.curve, x3, y3, z3)"
,,+
,,"+    def __sub__(self, b):"
,,+        assert b.curve == self.curve
,,+
,,"+        if not isinstance(b, ECPointJacobian):"
,,+            raise TypeError('b must be an ECPointJacobian object')
,,+
,,+        # b.curve.p - b.y is effectively -b.y % b.curve.p
,,"+        return self + ECPointJacobian(b.curve, b.x, b.curve.p - b.y, b.z)"
,,+
,,"+    def __mul__(self, k):"
,,"+        if not isinstance(k, int):"
,,+            raise TypeError('k must be an integer')
,,+
,,"+        return montgomery_ladder(k, ECPointJacobian(self.curve, self.x, self.y, self.z))"
,,+
,,+    def double(self):
,,"+        """""" Optimized point doubling operation that results in `2*self`."
,,+
,,+        Returns:
,,+            ECPointJacobian: The point corresponding to `2*self`.
,,"+        """""""
,,+        if self.y == 0:
,,"+            return ECPointJacobian(self.curve, 0, 1, 0, True)"
,,+
,,"+        y2 = pow(self.y, 2, self.curve.p)"
,,"+        y4 = pow(y2, 2, self.curve.p)"
,,+        z4 = (self.z3 * self.z) % self.curve.p
,,+
,,+        s = (4 * self.x * y2) % self.curve.p
,,"+        m = (3 * pow(self.x, 2, self.curve.p) + self.curve.a * z4) % self.curve.p"
,,+
,,"+        x = (pow(m, 2, self.curve.p) - 2 * s) % self.curve.p"
,,+        y = (m * (s - x) - 8 * y4) % self.curve.p
,,+        z = (2 * self.y * self.z) % self.curve.p
,,+
,,"+        return ECPointJacobian(self.curve, x, y, z)"
,,+
,,+    def to_affine(self):
,,"+        """""" Converts this point to an affine representation."
,,+
,,+        Returns:
,,+            ECPointAffine: The affine representation.
,,"+        """""""
,,+        if self.z == 0 or self.infinity:
,,+            # This is the point at infinity
,,"+            return ECPointAffine(self.curve, 0, 0, True)"
,,+
,,+        if self.z == 1:
,,"+            return ECPointAffine(self.curve, self.x, self.y)"
,,+
,,"+        x = (self.x * self.curve.modinv(self.z2, self.curve.p)) % self.curve.p"
,,"+        y = (self.y * self.curve.modinv(self.z3, self.curve.p)) % self.curve.p"
,,+
,,"+        return ECPointAffine(self.curve, x, y)"
,,+
,,+    def to_jacobian(self):
,,"+        """""" No-op since this is already a Jacobian point."
,,+
,,+        Returns:
,,+            ECPointJacobian: Just returns this point.
,,"+        """""""
,,+        return self
,,+
,,+
,,+class ECPointAffine(ECPoint):
,,"+    """""" Encapsulates a point on an elliptic curve."
,,+
,,+    This class provides an affine representation of a point
,,+    on an elliptic curve. It presents the standard addition and
,,+    scalar multiplication operations between two points as overloaded
,,+    '+' and '*' Python operators. Scalar multiplications are computed
,,+    via the Montgomery Ladder technique.
,,+
,,+    Args:
,,+        curve (EllipticCurve): The curve the point is on.
,,+        x (int): x component of point.
,,+        y (int): y component of point.
,,+
,,+    Returns:
,,"+        ECPointAffine: the point formed by (x, y) on curve."
,,"+    """""""
,,+    @staticmethod
,,+    def from_affine(affine_point):
,,"+        """""" A no-op since the point is already affine."
,,+
,,+        Args:
,,+            affine_point (ECPointAffine): A Affine point
,,+
,,+        Returns:
,,+            ECPointAffine: Returns the input arg.
,,"+        """""""
,,+        return affine_point
,,+
,,+    @staticmethod
,,+    def from_jacobian(jacobian_point):
,,"+        """""" Converts from a Jacobian point to an affine representation."
,,+
,,+        Args:
,,+            jacobian_point (ECPointJacobian): The Jacobian point to convert.
,,+
,,+        Returns:
,,+            ECPointAffine: The affine representation.
,,"+        """""""
,,+        return jacobian_point.to_affine()
,,+
,,+    @staticmethod
,,"+    def from_int(curve, i):"
,,"+        """""" Creates a point from an integer."
,,+
,,+        Assumes that pt.y is the lower bits of i and pt.x is
,,+        the upper bits of i.
,,+
,,+        Args:
,,+            curve (EllipticCurve): The curve to which the point belongs.
,,+            i (int): integer representing the point.
,,+
,,+        Returns:
,,+            ECPointAffine: point on curve.
,,"+        """""""
,,+        x = i >> curve.nlen
,,+        y = i & (2**curve.nlen - 1)
,,+
,,"+        assert curve.is_on_curve(Point(x, y))"
,,+
,,"+        return ECPointAffine(curve, x, y)"
,,+
,,"+    def __init__(self, curve, x, y, infinity=False):"
,,"+        super().__init__(curve, x, y, 1, infinity)"
,,+
,,+    def __str__(self):
,,"+        return 'O' if self.infinity else f'({self.x:032x}, {self.y:032x})'"
,,+
,,"+    def __add__(self, b):"
,,+        assert b.curve == self.curve
,,+
,,"+        if not isinstance(b, ECPointAffine):"
,,+            raise TypeError('b must be an ECPointAffine object')
,,+
,,+        # See https://www.certicom.com/index.php/32-arithmetic-in-an-elliptic-curve-group-over-fp
,,+        if self.infinity:
,,+            return b
,,+        if b.infinity:
,,+            return self
,,+        if self == b:
,,+            return self.double()
,,+
,,+        if (self.x == b.x) and ((self.y != b.y) or (self.y == 0 and b.y == 0)):
,,"+            return ECPointAffine(self.curve, 0, 0, True)"
,,+
,,+        s = self._slope(b)
,,+        xr = (s**2 - self.x - b.x) % self.curve.p
,,+        yr = (-self.y + s * (self.x - xr)) % self.curve.p
,,+
,,"+        assert self.curve.is_on_curve(Point(xr, yr))"
,,+
,,"+        return ECPointAffine(self.curve, xr, yr)"
,,+
,,"+    def __sub__(self, b):"
,,+        assert b.curve == self.curve
,,+
,,"+        if not isinstance(b, ECPointAffine):"
,,+            raise TypeError('b must be an ECPointAffine object')
,,+
,,"+        return self + ECPointAffine(b.curve, b.x, b.curve.p - b.y)"
,,+
,,"+    def __mul__(self, k):"
,,"+        if not isinstance(k, int):"
,,+            raise TypeError('k must be an integer')
,,+
,,"+        return montgomery_ladder(k, ECPointAffine(self.curve, self.x, self.y))"
,,+
,,"+    def _slope(self, q):"
,,"+        """""" Determines the slope between this point and another"
,,+            on this point's curve.
,,+
,,+        Args:
,,+            q (ECPointAffine): Second point
,,+
,,+        Returns:
,,+            int: Slope between self and q.
,,"+        """""""
,,+        n = self.y - q.y
,,+        d = self.x - q.x
,,"+        d_modinv = EllipticCurve.modinv(d, self.curve.p)"
,,+        return (n * d_modinv) % self.curve.p
,,+
,,+    def double(self):
,,"+        """""" Doubles this point."
,,+
,,+        Returns:
,,+            ECPointAffine: The point corresponding to 2*self.
,,"+        """""""
,,+        if self.infinity:
,,+            return self
,,+
,,"+        s = ((3 * self.x**2 + self.curve.a) * self.curve.modinv(2 * self.y, self.curve.p)) % self.curve.p"
,,+        xr = (s**2 - (2 * self.x)) % self.curve.p
,,+        yr = (-self.y + s * (self.x - xr)) % self.curve.p
,,+
,,"+        assert self.curve.is_on_curve(Point(xr, yr))"
,,+
,,"+        return ECPointAffine(self.curve, xr, yr)"
,,+
,,+    def to_affine(self):
,,"+        """""" No-op since this is already a Affine point."
,,+
,,+        Returns:
,,+            ECPointAffine: Just returns this point.
,,"+        """""""
,,+        return self
,,+
,,+    def to_jacobian(self):
,,"+        """""" Converts this point to an jacobian representation."
,,+
,,+        Returns:
,,+            ECPointJacobian: The jacobian representation.
,,"+        """""""
,,"+        return ECPointJacobian(self.curve, self.x, self.y, 1, self.infinity)"
,,+
,,+    @property
,,+    def compressed_bytes(self):
,,"+        """""" Returns the compressed bytes for this point."
,,+
,,"+        If pt.y is odd, 0x03 is pre-pended to pt.x."
,,"+        If pt.y is even, 0x02 is pre-pended to pt.x."
,,+
,,+        Returns:
,,+            bytes: Compressed byte representation.
,,"+        """""""
,,+        nbytes = math.ceil(self.curve.nlen / 8)
,,"+        return bytes([(self.y & 0x1) + 0x02]) + self.x.to_bytes(nbytes, 'big')"
,,+
,,+    def __bytes__(self):
,,"+        """""" Returns the full-uncompressed point"
,,"+        """""""
,,+        nbytes = math.ceil(self.curve.nlen / 8)
,,"+        return bytes([0x04]) + self.x.to_bytes(nbytes, 'big') + self.y.to_bytes(nbytes, 'big')"
,,+
,,+
,,+class EllipticCurve(EllipticCurveBase):
,,"+    """""" A generic class for elliptic curves and operations on them."
,,+
,,+    The curves must be of the form: y^2 = x^3 + a*x + b.
,,+
,,+    Args:
,,+        p (int): Prime that defines the field.
,,+        a (int): linear coefficient of the curve.
,,+        b (int): constant of the curve.
,,+        n (int): order of G (smallest prime) such that nG = infinity.
,,+        G (Point): generator (base point) of the curve.
,,+        h (int): The curve co-factor.
,,+        hash_function (function): The function to use for hashing messages.
,,"+    """""""
,,+    @staticmethod
,,"+    def _extended_gcd(aa, bb):"
,,+        # https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm
,,"+        lastremainder, remainder = abs(aa), abs(bb)"
,,"+        x, lastx, y, lasty = 0, 1, 1, 0"
,,+        while remainder:
,,"+            lastremainder, (quotient, remainder) = remainder, divmod(lastremainder, remainder)"
,,"+            x, lastx = lastx - quotient * x, x"
,,"+            y, lasty = lasty - quotient * y, y"
,,"+        return lastremainder, lastx * (-1 if aa < 0 else 1), lasty * (-1 if bb < 0 else 1)"
,,+
,,+    @staticmethod
,,"+    def modinv(a, n):"
,,"+        """""" Provides the modular inverse of a wrt n."
,,+
,,+        This uses the extended Euclidean algorithm to compute the
,,"+        the GCD of a, n."
,,+
,,+        Args:
,,+            a (int): number to find modular inverse of
,,+            n (int): modulus
,,"+        """""""
,,+        # From http://rosettacode.org/wiki/Modular_inverse#Python
,,"+        g, x, y = EllipticCurve._extended_gcd(a, n)"
,,+        if g != 1:
,,"+            raise ValueError('in EllipticCurve.modinv: g (%d) != 1, x = %d, y = %d' % (g, x, y))"
,,+        return x % n
,,+
,,+    @staticmethod
,,"+    def modsqrt(a, n):"
,,+        if a == 0:
,,+            return 0
,,+        elif n == 2:
,,+            return n
,,+        elif n % 4 == 3:
,,"+            return pow(a, (n + 1) // 4, n)"
,,+        else:
,,+            raise NotImplementedError(
,,"+                ""The generalized modular square root using Tonelli-Shanks hasn't been implemented yet."", )"
,,+
,,"+    def __init__(self, p, a, b, n, G, h, hash_function):"
,,+        super().__init__(hash_function)
,,+        self.a = a
,,+        self.b = b
,,+        self.p = p
,,+        self.n = n
,,+        self.G = G
,,+        self.h = h
,,+
,,+        self.nlen = self.n.bit_length()
,,+        self.plen = self.p.bit_length()
,,+
,,"+    def __eq__(self, other_curve):"
,,+        return (self.a == other_curve.a) and (self.b == other_curve.b) and \
,,+            (self.p == other_curve.p) and (self.n == other_curve.n) and (self.G == other_curve.G)
,,+
,,"+    def is_on_curve(self, p):"
,,"+        """""" Checks whether a point is on the curve."
,,+
,,+        Args:
,,+            p (ECPointAffine): Point to be checked
,,+
,,+        Returns:
,,"+            bool: True if p is on the curve, False otherwise."
,,"+        """""""
,,"+        return (pow(p.y, 2, self.p) - pow(p.x, 3, self.p) - self.a * p.x - self.b) % self.p == 0"
,,+
,,+    @property
,,+    def base_point(self):
,,"+        """""" Returns the base point for this curve."
,,+
,,+        Returns:
,,+            ECPointJacobian: the base point
,,"+        """""""
,,"+        return ECPointJacobian(self, self.G.x, self.G.y, 1)"
,,+
,,"+    def y_from_x(self, x):"
,,"+        """""" Computes the y component corresponding to x."
,,+
,,"+        Since elliptic curves are symmetric about the x-axis,"
,,+        the x component (and sign) is all that is required to determine
,,+        a point on the curve.
,,+
,,+        Args:
,,+            x (int): x component of the point.
,,+
,,+        Returns:
,,+            tuple: both possible y components of the point.
,,"+        """""""
,,"+        a = (pow(x, 3, self.p) + self.a * x + self.b) % self.p"
,,"+        y1 = self.modsqrt(a, self.p)"
,,+        y2 = self.p - y1
,,+        rv = []
,,+
,,"+        if self.is_on_curve(Point(x, y1)):"
,,+            rv.append(y1)
,,"+        if self.is_on_curve(Point(x, y2)):"
,,+            # Put the even parity one first.
,,+            if y2 & 0x1 == 1:
,,+                rv.append(y2)
,,+            else:
,,"+                rv.insert(0, y2)"
,,+
,,+        return rv
,,+
,,"+    def gen_key_pair(self, random_generator=random.SystemRandom()):"
,,"+        """""" Generates a public/private key pair."
,,+
,,+        Args:
,,+            random_generator (generator): The random generator to use.
,,+        Returns:
,,+            tuple:
,,+                A private key in the range of 1 to `self.n - 1`
,,+                and an ECPointAffine containing the public key point.
,,"+        """""""
,,"+        private = random_generator.randrange(1, self.n)"
,,"+        return private, self.public_key(private)"
,,+
,,"+    def public_key(self, private_key):"
,,"+        """""" Returns the public (verifying) key for a given private key."
,,+
,,+        Args:
,,+            private_key (int): the private key to derive the public key for.
,,+
,,+        Returns:
,,+            ECPointAffine: The point representing the public key.
,,"+        """""""
,,+        public = (self.base_point * private_key).to_affine()
,,+
,,+        return public
,,+
,,"+    def recover_public_key(self, message, signature, recovery_id=None):"
,,"+        """""" Recovers possibilities for the public key associated with the"
,,+        private key used to sign message and generate signature.
,,+
,,+        Since there are multiple possibilities (two for curves with
,,"+        co-factor = 1), each possibility that successfully verifies the"
,,+        signature is returned.
,,+
,,+        Args:
,,+           message (bytes): The message that was signed.
,,+           signature (ECPointAffine): The point representing the signature.
,,"+           recovery_id (int) (Optional): If provided, limits the valid x and y"
,,+              point to only that described by the recovery_id.
,,+
,,+        Returns:
,,+           list(ECPointAffine): List of points representing valid public
,,+           keys that verify signature.
,,"+        """""""
,,+        r = signature.x
,,+        s = signature.y
,,+
,,"+        r_modinv = self.modinv(r, self.n)"
,,+
,,+        if recovery_id is not None:
,,+            i_list = [recovery_id >> 1]
,,+            k_list = [recovery_id & 0x1]
,,+        else:
,,+            i_list = range(2)
,,+            k_list = range(2)
,,+
,,+        rv = []
,,+        num_bytes = math.ceil(self.nlen / 8)
,,+        for i in i_list:
,,+            x = (r + self.n * i) % self.p
,,+            ys = self.y_from_x(x)
,,+            if not ys:
,,+                continue
,,+
,,+            for k in k_list:
,,"+                # if k == 0, we want even parity, else odd"
,,+                y = ys[k]
,,+                if y & 0x1 != k:
,,+                    y = ys[k ^ 1]
,,"+                R = ECPointJacobian(self, r, y, 1)"
,,+
,,+                if not (R * self.n).to_affine().infinity:
,,+                    continue
,,+
,,"+                z = int.from_bytes(self.hash_function(message).digest()[:num_bytes], 'big')"
,,+
,,+                zG = self.base_point * z
,,+                pub_key = ((R * s - zG) * r_modinv).to_affine()
,,+
,,"+                rv.append((pub_key, 2 * i + k))"
,,+
,,+        return rv
,,+
,,"+    def _sign(self, message, private_key, do_hash=True, secret=None):"
,,+        hashed = self.hash_function(message).digest() if do_hash else message
,,"+        z = int.from_bytes(hashed, 'big')"
,,+
,,+        G = self.base_point
,,+
,,+        r = 0
,,+        s = 0
,,+        recovery_id = 0
,,+        while r == 0 or s == 0:
,,"+            k = self._nonce_rfc6979(private_key, hashed) if secret is None else secret"
,,+
,,+            p = (G * k).to_affine()
,,+            assert self.h == 1
,,+            recovery_id = 2 if p.x > self.n else 0
,,+            recovery_id |= (p.y & 0x1)
,,+            r = p.x % self.n
,,+            if r == 0:
,,+                continue
,,+
,,"+            s = ((z + r * private_key) * self.modinv(k, self.n)) % self.n"
,,+
,,"+        return (Point(r, s), recovery_id)"
,,+
,,"+    def verify(self, message, signature, public_key, do_hash=True):"
,,"+        """""" Verifies that signature was generated with a private key corresponding"
,,"+        to public key, operating on message."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed
,,"+            signature (Point): (r, s) representing the signature"
,,+            public_key (ECPointAffine): ECPointAffine of the public key
,,+            do_hash (bool): True if the message should be hashed prior
,,"+               to signing, False if not. This should always be left as"
,,+               True except in special situations which require doing
,,+               the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            bool: True if the signature is verified, False otherwise."
,,"+        """""""
,,+        r = signature.x
,,+        s = signature.y
,,+
,,+        hashed = self.hash_function(message).digest() if do_hash else message
,,"+        z = int.from_bytes(hashed, 'big')"
,,+
,,+        G = self.base_point
,,+
,,+        assert public_key.x >= 1 and public_key.x <= (self.n - 1)
,,+        assert public_key.y >= 1 and public_key.y <= (self.n - 1)
,,+
,,"+        w = self.modinv(s, self.n)"
,,+        u = (z * w) % self.n
,,+
,,+        v = (r * w) % self.n
,,+        pt = (G * u + ECPointJacobian.from_affine(public_key) * v).to_affine()
,,+
,,+        return r == (pt.x % self.n)
,,+
,,+
,,+class p256(EllipticCurve):
,,"+    """""" P-256 NIST-defined curve"
,,"+    """""""
,,+    P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff
,,+    A = 0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc
,,+    B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b
,,+    N = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
,,+    Gx = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
,,+    Gy = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
,,+    H = 1
,,+
,,+    def __init__(self):
,,"+        EllipticCurve.__init__(self, p256.P, p256.A, p256.B, p256.N, Point(p256.Gx, p256.Gy), p256.H, hashlib.sha256)"
,,+
,,+
,,+class secp256k1(EllipticCurve):
,,"+    """""" Elliptic curve used in Bitcoin."
,,"+    """""""
,,+    P = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f
,,+    A = 0
,,+    B = 7
,,+    N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
,,+    Gx = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798
,,+    Gy = 0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8
,,+    H = 1
,,+
,,+    def __init__(self):
,,+        EllipticCurve.__init__(
,,"+            self,"
,,"+            secp256k1.P,"
,,"+            secp256k1.A,"
,,"+            secp256k1.B,"
,,"+            secp256k1.N,"
,,"+            Point(secp256k1.Gx, secp256k1.Gy),"
,,"+            secp256k1.H,"
,,"+            hashlib.sha256,"
,,+        )
,,+import math
,,+import platform
,,+from ctypes import c_char_p
,,+from ctypes import c_int
,,+from ctypes import c_long
,,+from ctypes import c_void_p
,,+from ctypes import CDLL
,,+from ctypes import create_string_buffer
,,+from ctypes import POINTER
,,+from ctypes import Structure
,,+
,,+
,,+class OpenSSLSignature(Structure):
,,"+    _fields_ = [('r', c_void_p), ('s', c_void_p)]"
,,+
,,+
,,+sys_type = platform.system()
,,+if sys_type == 'Darwin':
,,+    libcrypto = CDLL('libcrypto.dylib')
,,+elif sys_type == 'Linux':
,,+    libcrypto = CDLL('libcrypto.so')
,,+else:
,,+    raise Exception('Unsupported platform %s' % sys_type)
,,+
,,+lc = libcrypto
,,+
,,+lc.OBJ_sn2nid.argtypes = [c_char_p]
,,+lc.OBJ_sn2nid.restype = c_int
,,+
,,+lc.EC_KEY_new_by_curve_name.restype = c_void_p
,,+lc.EC_KEY_generate_key.argtypes = [c_void_p]
,,+lc.EC_KEY_generate_key.restype = c_int
,,+lc.EC_KEY_check_key.argtypes = [c_void_p]
,,+lc.EC_KEY_check_key.restype = c_int
,,+lc.EC_KEY_get0_private_key.argtypes = [c_void_p]
,,+lc.EC_KEY_get0_private_key.restype = c_void_p
,,+lc.EC_KEY_get0_public_key.argtypes = [c_void_p]
,,+lc.EC_KEY_get0_public_key.restype = c_void_p
,,"+lc.EC_KEY_set_private_key.argtypes = [c_void_p, c_void_p]"
,,+lc.EC_KEY_set_private_key.restype = c_int
,,"+lc.EC_KEY_set_public_key.argtypes = [c_void_p, c_void_p]"
,,+lc.EC_KEY_set_public_key.restype = c_int
,,+lc.EC_KEY_get0_group.argtypes = [c_void_p]
,,+lc.EC_KEY_get0_group.restype = c_void_p
,,+lc.EC_KEY_free.argtypes = [c_void_p]
,,+
,,+lc.EC_GROUP_new_by_curve_name.restype = c_void_p
,,+lc.EC_GROUP_get_order.argtypes = [c_void_p] * 3
,,+lc.EC_GROUP_get_order.restype = c_int
,,+lc.EC_GROUP_get_curve_GFp.argtypes = [c_void_p] * 5
,,+lc.EC_GROUP_get_curve_GFp.restype = c_int
,,+lc.EC_GROUP_free.argtypes = [c_void_p]
,,+
,,+lc.EC_POINT_new.argtypes = [c_void_p]
,,+lc.EC_POINT_new.restype = c_void_p
,,+lc.EC_POINT_point2oct.argtypes = [c_void_p]
,,+lc.EC_POINT_point2oct.restype = c_int
,,+lc.EC_POINT_mul.argtypes = [c_void_p] * 6
,,+lc.EC_POINT_mul.restype = c_int
,,+lc.EC_POINT_invert.argtypes = [c_void_p] * 3
,,+lc.EC_POINT_invert.restype = c_int
,,+lc.EC_POINT_get_affine_coordinates_GFp.argtypes = [c_void_p] * 5
,,+lc.EC_POINT_set_affine_coordinates_GFp.argtypes = [c_void_p] * 5
,,+lc.EC_POINT_set_affine_coordinates_GFp.restype = c_int
,,"+lc.EC_POINT_set_compressed_coordinates_GFp.argtypes = [c_void_p, c_void_p, c_void_p, c_int, c_void_p]"
,,+lc.EC_POINT_set_compressed_coordinates_GFp.restype = c_int
,,"+lc.EC_POINT_is_at_infinity.argtypes = [c_void_p, c_void_p]"
,,+lc.EC_POINT_is_at_infinity.restype = c_int
,,"+lc.EC_POINT_set_to_infinity.argtypes = [c_void_p, c_void_p]"
,,+lc.EC_POINT_set_to_infinity.restype = c_int
,,+lc.EC_POINT_is_on_curve.argtypes = [c_void_p] * 3
,,+lc.EC_POINT_is_on_curve.restype = c_int
,,+
,,"+lc.d2i_ECDSA_SIG.argtypes = [c_void_p, c_void_p, c_long]"
,,+lc.d2i_ECDSA_SIG.restype = POINTER(OpenSSLSignature)
,,+lc.ECDSA_SIG_new.argtypes = []
,,+lc.ECDSA_SIG_new.restype = POINTER(OpenSSLSignature)
,,+lc.ECDSA_SIG_free.argtypes = [POINTER(OpenSSLSignature)]
,,"+lc.ECDSA_do_sign_ex.argtypes = [c_char_p, c_int, c_void_p, c_void_p, c_void_p]"
,,+lc.ECDSA_do_sign_ex.restype = POINTER(OpenSSLSignature)
,,"+lc.ECDSA_do_verify.argtypes = [c_void_p, c_int, POINTER(OpenSSLSignature), c_void_p]"
,,+lc.ECDSA_do_verify.restype = c_int
,,+
,,+lc.BN_new.restype = c_void_p
,,+lc.BN_num_bits.argtypes = [c_void_p]
,,+lc.BN_num_bits.restype = c_int
,,"+lc.BN_bn2bin.argtypes = [c_void_p, c_char_p]"
,,+lc.BN_bn2bin.restype = c_int
,,"+lc.BN_bin2bn.argtypes = [c_char_p, c_int, c_void_p]"
,,+lc.BN_bin2bn.restype = c_void_p
,,+lc.BN_mod_mul.argtypes = [c_void_p] * 5
,,+lc.BN_mod_mul.restype = c_int
,,+lc.BN_mod_add.argtypes = [c_void_p] * 5
,,+lc.BN_mod_add.restype = c_int
,,+lc.BN_mod_inverse.argtypes = [c_void_p] * 4
,,+lc.BN_mod_inverse.restype = c_void_p
,,+lc.BN_free.argtypes = [c_void_p]
,,+lc.BN_CTX_new.restype = c_void_p
,,+lc.BN_CTX_start.argtypes = [c_void_p]
,,+lc.BN_CTX_get.argtypes = [c_void_p]
,,+lc.BN_CTX_get.restype = c_void_p
,,+lc.BN_CTX_end.argtypes = [c_void_p]
,,+lc.BN_CTX_free.argtypes = [c_void_p]
,,+
,,+lc.ERR_load_crypto_strings()
,,+
,,+
,,+def get_curve_params(group):
,,"+    """""" Retrieves all elliptic curve parameters"
,,+
,,+    Args:
,,+        group (c_void_p): The OpenSSL group (curve) to
,,+            retrieve the parameters for.
,,+
,,+    Returns:
,,+        dict: With the following key/value pairs:
,,+            p: Prime defining the field
,,+            a: Linear coefficient of the curve
,,+            b: Curve constant
,,+            n: Curve order
,,+            h: Curve co-factor
,,"+    """""""
,,+    ctx = c_void_p(lc.BN_CTX_new())
,,+    lc.BN_CTX_start(ctx)
,,+
,,+    order_bn = c_void_p(lc.BN_CTX_get(ctx))
,,+    cofactor_bn = c_void_p(lc.BN_CTX_get(ctx))
,,+    p_bn = c_void_p(lc.BN_CTX_get(ctx))
,,+    a_bn = c_void_p(lc.BN_CTX_get(ctx))
,,+    b_bn = c_void_p(lc.BN_CTX_get(ctx))
,,"+    lc.EC_GROUP_get_order(group, order_bn, c_void_p())"
,,"+    lc.EC_GROUP_get_cofactor(group, cofactor_bn, c_void_p())"
,,"+    lc.EC_GROUP_get_curve_GFp(group, p_bn, a_bn, b_bn, ctx)"
,,+
,,+    rv = {}
,,+    rv['p'] = bn_to_int(p_bn)
,,+    rv['a'] = bn_to_int(a_bn)
,,+    rv['b'] = bn_to_int(b_bn)
,,+    rv['n'] = bn_to_int(order_bn)
,,+    rv['h'] = bn_to_int(cofactor_bn)
,,+
,,+    lc.BN_CTX_end(ctx)
,,+    lc.BN_CTX_free(ctx)
,,+
,,+    return rv
,,+
,,+
,,"+def new_key(curve_name, private_key=None):"
,,"+    """""" Generates a new EC_KEY"
,,+
,,+    Args:
,,+        curve_name (int): The OpenSSL identifier of the curve which
,,+            the key will be part of.
,,"+        private_key (int): If not provided, a random key pair will be"
,,"+            generated. Otherwise, the key will be initiated with the"
,,+            provided private key (and corresponding public key)
,,+
,,+    Returns:
,,+        c_void_p: An opaque pointer to the new EC_KEY object. The
,,+            caller is responsible for freeing the key object.
,,"+    """""""
,,+    k = c_void_p(lc.EC_KEY_new_by_curve_name(curve_name))
,,+
,,+    if private_key is None:
,,+        lc.EC_KEY_generate_key(k)
,,+    else:
,,"+        key_ok = set_private_key_from_int(k, private_key)"
,,+        if not key_ok:
,,+            raise ValueError('Key is not ok')
,,+
,,+    return k
,,+
,,+
,,+def get_private_key_bytes(key):
,,"+    """""" Retrieves the bytes corresponding to the private key."
,,+
,,+    Args:
,,+        key (c_void_p): A pointer to an EC_KEY object.
,,+
,,+    Returns:
,,+        bytes: A byte stream containing the private key.
,,"+    """""""
,,+    priv_key_bn = c_void_p(lc.EC_KEY_get0_private_key(key))
,,+    priv_key_bytes = bn_to_bytes(priv_key_bn)
,,+
,,+    return priv_key_bytes
,,+
,,+
,,+def get_private_key_int(key):
,,"+    """""" Retrieves the integer corresponding to the private key."
,,+
,,+    Args:
,,+        key (c_void_p): A pointer to an EC_KEY object.
,,+
,,+    Returns:
,,+        int: The integer representation of the private key.
,,"+    """""""
,,+    rv = None
,,+    b = get_private_key_bytes(key)
,,+    if b is not None:
,,"+        rv = int.from_bytes(b, byteorder='big')"
,,+
,,+    return rv
,,+
,,+
,,"+def set_private_key_from_bytes(key, b):"
,,"+    """""" Sets the private portion of key from b."
,,+
,,+        This function also sets the public key portion of
,,+        key after computing the public key from the provided
,,+        bytes of the private key.
,,+
,,+    Args:
,,+        key (c_void_p): A pointer to an EC_KEY object.
,,+        b (bytes): The bytes representing the private key.
,,+
,,+    Returns:
,,+        bool: Whether key passes OpenSSL's sanity checks after
,,+            both private & public keys are set.
,,"+    """""""
,,+    priv_bn = bytes_to_bn(b)
,,+
,,+    group = c_void_p(lc.EC_KEY_get0_group(key))
,,+
,,"+    lc.EC_KEY_set_private_key(key, priv_bn)"
,,+
,,+    # Now jam the public key
,,+    pub_pt = c_void_p(lc.EC_POINT_new(group))
,,"+    lc.EC_POINT_mul(group, pub_pt, priv_bn, c_void_p(), c_void_p(), c_void_p())"
,,"+    lc.EC_KEY_set_public_key(key, pub_pt)"
,,+
,,+    lc.EC_POINT_free(pub_pt)
,,+
,,+    return lc.EC_KEY_check_key(key)
,,+
,,+
,,"+def set_private_key_from_int(key, i, size=32):"
,,"+    """""" Sets the private portion of key from i."
,,+
,,+        This function also sets the public key portion of
,,+        key after computing the public key from the provided
,,+        private key.
,,+
,,+    Args:
,,+        key (c_void_p): A pointer to an EC_KEY object.
,,+        i (int): The integer representing the private key.
,,+        size (int): Size in bytes the key should be.
,,+
,,+    Returns:
,,+        bool: Whether key passes OpenSSL's sanity checks after
,,+            both private & public keys are set.
,,"+    """""""
,,"+    b = i.to_bytes(size, byteorder='big')"
,,"+    return set_private_key_from_bytes(key, b)"
,,+
,,+
,,+def bn_to_bytes(bn):
,,"+    """""" Translates an OpenSSL big number (BN) to bytes."
,,+
,,+    Args:
,,+        bn (c_void_p): A pointer to an OpenSSL BN object.
,,+
,,+    Returns:
,,+        bytes: The bytes corresponding to the BN object. It is
,,+            returned as a big-endian positive number.
,,"+    """""""
,,+    size = math.ceil(lc.BN_num_bits(bn) / 8.0)
,,+    b = create_string_buffer(b'\x00' * size)
,,"+    lc.BN_bn2bin(bn, b)"
,,+
,,+    return b[:size]
,,+
,,+
,,"+def bytes_to_bn(b, bn=None):"
,,"+    """""" Translates bytes to an OpenSSL big number (BN)."
,,+
,,+    Args:
,,"+        b (bytes): Big-endian, positive number to translate."
,,"+        bn (c_void_p): If not None, sets it to the number represented"
,,+            by b.
,,+
,,+    Returns:
,,"+        c_void_p: If bn is None, a pointer to a new OpenSSL BN object,"
,,"+             otherwise bn. In all cases, the caller is responsible for"
,,+             freeing the memory associated with the OpenSSL object.
,,"+    """""""
,,+    buf = create_string_buffer(b)
,,"+    return c_void_p(lc.BN_bin2bn(buf, len(b), bn))"
,,+
,,+
,,+def bn_to_int(bn):
,,"+    """""" Translates an OpenSSL big number (BN) to a Python integer."
,,+
,,+    Args:
,,+        bn (c_void_p): A pointer to an OpenSSL BN object.
,,+
,,+    Returns:
,,+        int: The python integer corresponding to the BN object.
,,"+    """""""
,,"+    return int.from_bytes(bn_to_bytes(bn), byteorder='big')"
,,+
,,+
,,"+def int_to_bn(i, bn=None, size=32):"
,,"+    """""" Translates a python integer to an OpenSSL big number (BN)."
,,+
,,+    Args:
,,+        i (int): Integer to translate.
,,"+        bn (c_void_p): If not None, sets it to the number represented"
,,+            by i.
,,+        size (int): The maximal byte-length of i.
,,+
,,+    Returns:
,,"+        c_void_p: If bn is None, a pointer to a new OpenSSL BN object,"
,,"+             otherwise bn. In all cases, the caller is responsible for"
,,+             freeing the memory associated with the OpenSSL object.
,,"+    """""""
,,"+    return bytes_to_bn(i.to_bytes(size, byteorder='big'), bn)"
,,+
,,+
,,"+def point_get_xy_bytes(group, pt):"
,,"+    """""" Gets bytes for x and y components of an EC_POINT."
,,+
,,+        This uses `bn_to_bytes` to create the bytes objects after
,,+        extracting the x and y components of pt.
,,+
,,+    Args:
,,+        group (c_void_p): An opaque pointer to the group (curve) that
,,+            pt is part of.
,,+        pt (c_void_p): An opaque pointer to the OpenSSL EC_POINT object.
,,+
,,+    Returns:
,,"+        tuple: Containing the x bytes, y bytes and a boolean representing"
,,+            whether the point is at infinity or not.
,,"+    """""""
,,+    x_bn = c_void_p(lc.BN_new())
,,+    y_bn = c_void_p(lc.BN_new())
,,"+    lc.EC_POINT_make_affine(group, pt, c_void_p(None))"
,,"+    lc.EC_POINT_get_affine_coordinates_GFp(group, pt, x_bn, y_bn, c_void_p(None))"
,,"+    inf = bool(lc.EC_POINT_is_at_infinity(group, pt))"
,,+
,,+    x_bytes = bn_to_bytes(x_bn)
,,+    y_bytes = bn_to_bytes(y_bn)
,,+
,,+    lc.BN_free(x_bn)
,,+    lc.BN_free(y_bn)
,,+
,,"+    return (x_bytes, y_bytes, inf)"
,,+
,,+
,,"+def point_get_xy_ints(group, pt):"
,,"+    """""" Gets the x and y components of an EC_POINT."
,,+
,,+    Args:
,,+        group (c_void_p): An opaque pointer to the group (curve) that
,,+            pt is part of.
,,+        pt (c_void_p): An opaque pointer to the OpenSSL EC_POINT object.
,,+
,,+    Returns:
,,"+        tuple: Containing x, y and a boolean representing whether the"
,,+            point is at infinity or not.
,,"+    """""""
,,"+    x_b, y_b, inf = point_get_xy_bytes(group, pt)"
,,"+    x = int.from_bytes(x_b, byteorder='big')"
,,"+    y = int.from_bytes(y_b, byteorder='big')"
,,+
,,"+    return (x, y, inf)"
,,+
,,+
,,"+def point_new_from_bytes(group, x_bytes, y_bytes, infinity=False):"
,,"+    """""" Creates a new OpenSSL EC_POINT from bytes."
,,+
,,+    Args:
,,+        group (c_void_p): An opaque pointer to the group (curve) that
,,+            the point should be part of.
,,"+        x_bytes (bytes): Big-endian, positive byte representation of x."
,,"+        y_bytes (bytes): Big-endian, positive byte representation of y."
,,"+        infinity (bool): True if the point is at infinity, False otherwise."
,,+
,,+    Returns:
,,+        c_void_p: An opaque pointer to the newly constructed OpenSSL
,,+            EC_POINT object. The caller bears responsibility for freeing
,,+            the memory associated with the returned object.
,,"+    """""""
,,+    pt = c_void_p(lc.EC_POINT_new(group))
,,+
,,+    x_bn = bytes_to_bn(x_bytes)
,,+    y_bn = bytes_to_bn(y_bytes)
,,+
,,"+    res = lc.EC_POINT_set_affine_coordinates_GFp(group, pt, x_bn, y_bn, c_void_p(None))"
,,+    if not res:
,,+        lc.EC_POINT_free(pt)
,,+        return None
,,+
,,+    if infinity:
,,"+        lc.EC_POINT_set_to_infinity(group, pt)"
,,+
,,+    return pt
,,+
,,+
,,"+def point_new_from_ints(group, x, y, infinity=False, size=32):"
,,"+    """""" Creates a new OpenSSL EC_POINT from x & y integers."
,,+
,,+    Args:
,,+        group (c_void_p): An opaque pointer to the group (curve) that
,,+            the point should be part of.
,,"+        x_bytes (bytes): Big-endian, positive byte representation of x."
,,"+        y_bytes (bytes): Big-endian, positive byte representation of y."
,,"+        infinity (bool): True if the point is at infinity, False otherwise."
,,+        size (int): Maximal byte-length of x and y.
,,+
,,+    Returns:
,,+        c_void_p: An opaque pointer to the newly constructed OpenSSL
,,+            EC_POINT object. The caller bears responsibility for freeing
,,+            the memory associated with the returned object.
,,"+    """""""
,,"+    x_bytes = x.to_bytes(size, byteorder='big')"
,,"+    y_bytes = y.to_bytes(size, byteorder='big')"
,,+
,,"+    return point_new_from_bytes(group, x_bytes, y_bytes, infinity)"
,,+
,,+
,,+def get_public_key_bytes(key):
,,"+    """""" Returns the bytes corresponding to the public key coordinates."
,,+
,,+    Args:
,,+        key (c_void_p): An opaque pointer to an OpenSSL EC_KEY object.
,,+
,,+    Returns:
,,+        tuple: Containing bytes for x & y public key components and a
,,+            boolean indicating whether the point is at infinity or not.
,,"+    """""""
,,+    group = c_void_p(lc.EC_KEY_get0_group(key))
,,+    pub_key_point = c_void_p(lc.EC_KEY_get0_public_key(key))
,,"+    x_b, y_b, inf = point_get_xy_bytes(group, pub_key_point)"
,,+
,,"+    return (x_b, y_b, inf)"
,,+
,,+
,,+def get_public_key_ints(key):
,,"+    """""" Returns the integers corresponding to the public key coordinates."
,,+
,,+    Args:
,,+        key (c_void_p): An opaque pointer to an OpenSSL EC_KEY object.
,,+
,,+    Returns:
,,+        tuple: Containing the x & y public key components and a
,,+            boolean indicating whether the point is at infinity or not.
,,"+    """""""
,,"+    xb, yb, inf = get_public_key_bytes(key)"
,,"+    x = int.from_bytes(xb, byteorder='big')"
,,"+    y = int.from_bytes(yb, byteorder='big')"
,,+
,,"+    return (x, y, inf)"
,,+
,,+
,,"+def set_public_key_from_bytes(key, x_bytes, y_bytes, infinity):"
,,"+    """""" Sets the public key portion of an OpenSSL EC_KEY object from"
,,+        bytes representations of the x & y components of the public key.
,,+
,,+    Args:
,,+        key (c_void_p): An opaque pointer to an OpenSSL EC_KEY object.
,,"+        x_bytes (bytes): Big-endian, positive byte-representation of the"
,,+            x component of the public-key point.
,,"+        y_bytes (bytes): Big-endian, positive byte-representation of the"
,,+            y component of the public-key point.
,,"+        infinity (bool): True if the point is at infinity, False otherwise."
,,+
,,+    Returns:
,,"+        bool: True if the public key was set properly, False otherwise."
,,"+    """""""
,,+    group = c_void_p(lc.EC_KEY_get0_group(key))
,,"+    pub_pt = point_new_from_bytes(group, x_bytes, y_bytes, infinity)"
,,"+    res = lc.EC_KEY_set_public_key(key, pub_pt)"
,,+
,,+    return bool(res)
,,+
,,+
,,"+def set_public_key_from_ints(key, x, y, infinity, size=32):"
,,"+    """""" Sets the public key portion of an OpenSSL EC_KEY object from"
,,+        bytes representations of the x & y components of the public key.
,,+
,,+    Args:
,,+        key (c_void_p): An opaque pointer to an OpenSSL EC_KEY object.
,,+        x (int): X component of the public-key point.
,,+        y (int): Y component of the public-key point.
,,"+        infinity (bool): True if the point is at infinity, False otherwise."
,,+        size (int): Maximal byte-size of x and y.
,,+
,,+    Returns:
,,"+        bool: True if the public key was set properly, False otherwise."
,,"+    """""""
,,"+    x_bytes = x.to_bytes(size, byteorder='big')"
,,"+    y_bytes = y.to_bytes(size, byteorder='big')"
,,"+    return set_public_key_from_bytes(key, x_bytes, y_bytes, infinity)"
,,+
,,+
,,"+def sig_new_from_bytes(r_bytes, s_bytes):"
,,"+    """""" Creates a new OpenSSL ECDSA_SIG structure from r & s bytes."
,,+
,,+    Args:
,,"+        r_bytes (bytes): Big-endian, positive byte-representation of the"
,,+            r component of the signature.
,,"+        s_bytes (bytes): Big-endian, positive byte-representation of the"
,,+            s component of the signature.
,,+
,,+    Returns:
,,+        c_void_p: An opaque pointer to a new OpenSSL ECDSA_SIG structure
,,+            represented by the `OpenSSLSignature` class.
,,"+    """""""
,,+    sig = lc.ECDSA_SIG_new()
,,+
,,+    r_buf = create_string_buffer(r_bytes)
,,+    s_buf = create_string_buffer(s_bytes)
,,"+    lc.BN_bin2bn(r_buf, len(r_bytes), sig.contents.r)"
,,"+    lc.BN_bin2bn(s_buf, len(s_bytes), sig.contents.s)"
,,+
,,+    return sig
,,+
,,+
,,"+def sig_new_from_ints(r, s, size=32):"
,,"+    """""" Creates a new OpenSSL ECDSA_SIG structure from r & s integers."
,,+
,,+    Args:
,,+        r (int): R component of the signature.
,,+        s (int): S component of the signature.
,,+        size (int): Maximal byte-size of r & s.
,,+
,,+    Returns:
,,+        c_void_p: An opaque pointer to a new OpenSSL ECDSA_SIG structure
,,+            represented by the `OpenSSLSignature` class.
,,"+    """""""
,,"+    return sig_new_from_bytes(r_bytes=r.to_bytes(size, byteorder='big'), s_bytes=s.to_bytes(size, byteorder='big'))"
,,"+""""""This submodule provides functions for accomplishing common tasks encountered"
,,"+in creating and parsing Bitcoin objects, like turning difficulties into targets"
,,"+or deserializing and serializing various kinds of packed byte formats."""""""
,,+import codecs
,,+import hashlib
,,+import os
,,+import random
,,+import struct
,,+
,,+import base58
,,+
,,+MAX_TARGET = 0x00000000FFFF0000000000000000000000000000000000000000000000000000
,,+
,,+
,,"+def rand_bytes(n, secure=True):"
,,"+    """""" Returns n random bytes."
,,+
,,+    Args:
,,+        n (int): number of bytes to return.
,,"+        secure (bool): If True, uses os.urandom to generate"
,,"+            cryptographically secure random bytes. Otherwise, uses"
,,+            random.randint() which generates pseudo-random numbers.
,,+
,,+    Returns:
,,+        b (bytes): n random bytes.
,,"+    """""""
,,+    if secure:
,,+        return os.urandom(n)
,,+    else:
,,"+        return bytes([random.randint(0, 255) for i in range(n)])"
,,+
,,+
,,+def bytes_to_str(b):
,,"+    """""" Converts bytes into a hex-encoded string."
,,+
,,+    Args:
,,+        b (bytes): bytes to encode
,,+
,,+    Returns:
,,+        h (str): hex-encoded string corresponding to b.
,,"+    """""""
,,"+    return codecs.encode(b, 'hex_codec').decode('ascii')"
,,+
,,+
,,+def hex_str_to_bytes(h):
,,"+    """""" Converts a hex-encoded string to bytes."
,,+
,,+    Args:
,,+        h (str): hex-encoded string to convert.
,,+
,,+    Returns:
,,+        b (bytes): bytes corresponding to h.
,,"+    """""""
,,+    return bytes.fromhex(h)
,,+
,,+
,,+# Is there a better way of doing this?
,,+def render_int(n):
,,"+    """""" Renders an int in the shortest possible form."
,,+
,,"+    When packing the height into the coinbase script, the integer"
,,+    representing the height must be encoded in the shortest possible
,,+    manner. See: https://bitcoin.org/en/developer-reference#coinbase.
,,+
,,+    Args:
,,+        n (int): number to be encoded.
,,+
,,+    Returns:
,,+        b (bytes): bytes representing n in the shortest possible form.
,,"+    """""""
,,+    # little-endian byte stream
,,+    if n < 0:
,,+        neg = True
,,+        n = -n
,,+    else:
,,+        neg = False
,,+    r = []
,,+    while n:
,,+        r.append(n & 0xff)
,,+        n >>= 8
,,+    if neg:
,,+        if r[-1] & 0x80:
,,+            r.append(0x80)
,,+        else:
,,+            r[-1] |= 0x80
,,+    elif r and (r[-1] & 0x80):
,,+        r.append(0)
,,+    return bytes(r)
,,+
,,+
,,+def pack_compact_int(i):
,,"+    """""" See"
,,+    https://bitcoin.org/en/developer-reference#compactsize-unsigned-integers
,,+
,,+    Args:
,,+        i (int): Integer to be serialized.
,,+
,,+    Returns:
,,+        b (bytes): Serialized bytes corresponding to i.
,,"+    """""""
,,+    if i < 0xfd:
,,"+        return struct.pack('<B', i)"
,,+    elif i <= 0xffff:
,,"+        return struct.pack('<BH', 0xfd, i)"
,,+    elif i <= 0xffffffff:
,,"+        return struct.pack('<BI', 0xfe, i)"
,,+    else:
,,"+        return struct.pack('<BQ', 0xff, i)"
,,+
,,+
,,+def unpack_compact_int(bytestr):
,,"+    """""" See"
,,+    https://bitcoin.org/en/developer-reference#compactsize-unsigned-integers
,,+
,,+    Args:
,,+        bytestr (bytes): bytes containing an unsigned integer to be
,,+            deserialized.
,,+
,,+    Returns:
,,+        n (int): deserialized integer.
,,"+    """""""
,,+
,,+    b0 = bytestr[0]
,,+    if b0 < 0xfd:
,,"+        return (b0, bytestr[1:])"
,,+    elif b0 == 0xfd:
,,"+        return (struct.unpack('<H', bytestr[1:3])[0], bytestr[3:])"
,,+    elif b0 == 0xfe:
,,"+        return (struct.unpack('<I', bytestr[1:5])[0], bytestr[5:])"
,,+    elif b0 == 0xff:
,,"+        return (struct.unpack('<Q', bytestr[1:9])[0], bytestr[9:])"
,,+    else:
,,+        return None
,,+
,,+
,,+def pack_u32(i):
,,"+    """""" Serializes a 32-bit integer into little-endian form."
,,+
,,+    Args:
,,+        i (int): integer to be serialized.
,,+
,,+    Returns:
,,+        b (bytes): 4 bytes containing the little-endian serialization of i.
,,"+    """""""
,,"+    return struct.pack('<I', i)"
,,+
,,+
,,+def unpack_u32(b):
,,"+    """""" Deserializes a 32-bit integer from bytes."
,,+
,,+    Args:
,,+        b (bytes): At least 4 bytes containing the serialized integer.
,,+
,,+    Returns:
,,"+        (i, b) (tuple): A tuple containing the deserialized integer and the"
,,+        remainder of the byte stream.
,,"+    """""""
,,"+    u32 = struct.unpack('<I', b[0:4])"
,,"+    return (u32[0], b[4:])"
,,+
,,+
,,+def pack_u64(i):
,,"+    """""" Serializes a 64-bit integer into little-endian form."
,,+
,,+    Args:
,,+        i (int): integer to be serialized.
,,+
,,+    Returns:
,,+        b (bytes): 8 bytes containing the little-endian serialization of i.
,,"+    """""""
,,"+    return struct.pack('<Q', i)"
,,+
,,+
,,+def unpack_u64(b):
,,"+    """""" Deserializes a 64-bit integer from bytes."
,,+
,,+    Args:
,,+        b (bytes): At least 8 bytes containing the serialized integer.
,,+
,,+    Returns:
,,"+        (i, b) (tuple): A tuple containing the deserialized integer and the"
,,+        remainder of the byte stream.
,,"+    """""""
,,"+    u64 = struct.unpack('<Q', b[0:8])"
,,"+    return (u64[0], b[8:])"
,,+
,,+
,,+def pack_var_str(s):
,,"+    """""" Serializes a variable length byte stream."
,,+
,,+    Args:
,,+        s (bytes): byte stream to serialize
,,+
,,+    Return:
,,"+        b (bytes): Serialized bytes, prepended with the length of the"
,,+        byte stream.
,,"+    """""""
,,+    return pack_compact_int(len(s)) + s
,,+
,,+
,,+def unpack_var_str(b):
,,"+    """""" Deserializes a variable length byte stream."
,,+
,,+    Args:
,,+        b (bytes): variable length byte stream to deserialize
,,+
,,+    Returns:
,,"+        (s, b) (tuple): A tuple containing the variable length byte stream"
,,+        and the remainder of the input byte stream.
,,"+    """""""
,,"+    strlen, b0 = unpack_compact_int(b)"
,,"+    return (b0[:strlen], b0[strlen:])"
,,+
,,+
,,+def bits_to_target(bits):
,,"+    """""" Decodes the full target from a compact representation."
,,+    See: https://bitcoin.org/en/developer-reference#target-nbits
,,+
,,+    Args:
,,+        bits (int): Compact target (32 bits)
,,+
,,+    Returns:
,,+        target (Bignum): Full 256-bit target
,,"+    """""""
,,+    shift = bits >> 24
,,+    target = (bits & 0xffffff) * (1 << (8 * (shift - 3)))
,,+    return target
,,+
,,+
,,+def bits_to_difficulty(bits):
,,"+    """""" Determines the difficulty corresponding to bits."
,,+    See: https://en.bitcoin.it/wiki/Difficulty
,,+
,,+    Args:
,,+        bits (int): Compact target (32 bits)
,,+
,,+    Returns:
,,+        diff (float): Measure of how hard it is to find a solution
,,+        below the target represented by bits.
,,"+    """""""
,,+    target = bits_to_target(bits)
,,+    return MAX_TARGET / target
,,+
,,+
,,+def difficulty_to_target(difficulty):
,,"+    """""" Converts a difficulty to a long-form target."
,,+
,,+    Args:
,,+        difficulty (float): The difficulty to return the appropriate target for
,,+
,,+    Returns:
,,+        target (int): The corresponding target
,,"+    """""""
,,+    return int(MAX_TARGET / difficulty)
,,+
,,+
,,+def target_to_bits(target):
,,"+    """""" Creates a compact target representation for a given target."
,,+
,,+    Args:
,,+        target (Bignum): The long-form target to make compact.
,,+
,,+    Returns:
,,+        ct (int): Compact target
,,"+    """""""
,,+    # Get bit length
,,+    nbits = target.bit_length()
,,+    # Round up to next 8-bits
,,+    nbits = ((nbits + 7) & ~0x7)
,,+    exponent = (int(nbits / 8) & 0xff)
,,+    coefficient = (target >> (nbits - 24)) & 0xffffff
,,+    if coefficient & 0x800000:
,,+        coefficient >>= 8
,,+        exponent += 1
,,+    return (exponent << 24) | coefficient
,,+
,,+
,,+def difficulty_to_bits(difficulty):
,,"+    """""" Converts a difficulty to a compact target."
,,+
,,+    Args:
,,+        difficulty (float): The difficulty to create a target for
,,+
,,+    Returns:
,,+        ct (int): Compact target
,,"+    """""""
,,+    return target_to_bits(difficulty_to_target(difficulty))
,,+
,,+
,,+def address_to_key_hash(s):
,,"+    """""" Given a Bitcoin address decodes the version and"
,,+    RIPEMD-160 hash of the public key.
,,+
,,+    Args:
,,+        s (bytes): The Bitcoin address to decode
,,+
,,+    Returns:
,,"+        (version, h160) (tuple): A tuple containing the version and"
,,+        RIPEMD-160 hash of the public key.
,,"+    """""""
,,+    n = base58.b58decode_check(s)
,,+    version = n[0]
,,+    h160 = n[1:]
,,"+    return version, h160"
,,+
,,+
,,"+def key_hash_to_address(hash160, version=0x0):"
,,"+    """"""Convert RIPEMD-160 hash to bitcoin address."
,,+
,,+    Args:
,,+        hash160 (bytes/str): bitcoin hash160 to decode
,,+        version (int): The version prefix
,,+
,,+    Returns:
,,+        (bitcoin address): base58 encoded bitcoin address
,,"+    """""""
,,"+    if isinstance(hash160, str):"
,,"+        # if 0x in string, strip it"
,,+        if '0x' in hash160:
,,+            h160 = hex_str_to_bytes(hash160[2:])
,,+        else:
,,+            h160 = hex_str_to_bytes(hash160)
,,"+    elif isinstance(hash160, bytes):"
,,+        h160 = hash160
,,+
,,+    address = base58.b58encode_check(bytes([version]) + h160)
,,+    return address
,,+
,,+
,,+def hash160(b):
,,"+    """""" Computes the HASH160 of b."
,,+
,,+    Args:
,,+        b (bytes): A byte string to compute the HASH160 of.
,,+
,,+    Returns:
,,+        The RIPEMD-160 digest of the SHA256 hash of b.
,,"+    """""""
,,+    r = hashlib.new('ripemd160')
,,+    r.update(hashlib.sha256(b).digest())
,,+
,,+    return r.digest()
,,+
,,+
,,+def compute_reward(height):
,,"+    """""" Computes the block reward for a block at the supplied height."
,,+    See: https://en.bitcoin.it/wiki/Controlled_supply for the reward
,,+    schedule.
,,+
,,+    Args:
,,+        height (int): Block height
,,+
,,+    Returns:
,,+        reward (int): Number of satoshis rewarded for solving a block at the
,,+        given height.
,,"+    """""""
,,+    base_subsidy = 50 * 100000000
,,+    era = height // 210000
,,+    if era == 0:
,,+        return base_subsidy
,,+    return int(base_subsidy / 2**era)
,,+#!/usr/bin/env python
,,"+"""""""
,,+Code from:
,,+https://github.com/michailbrynard/ethereum-bip44-python
,,+
,,"+This submodule provides the PublicKey, PrivateKey, and Signature classes."
,,+It also provides HDPublicKey and HDPrivateKey classes for working with HD
,,"+wallets."""""""
,,+import base64
,,+import binascii
,,+import hashlib
,,+import hmac
,,+import math
,,+import random
,,+
,,+import base58
,,+from Cryptodome.Hash import keccak
,,+from mnemonic.mnemonic import Mnemonic
,,+
,,+from evmoswallet.crypto.ecdsa import ECPointAffine
,,+from evmoswallet.crypto.ecdsa import secp256k1
,,+from evmoswallet.crypto.ecdsa_base import Point
,,+from evmoswallet.crypto.utils import address_to_key_hash
,,+from evmoswallet.crypto.utils import bytes_to_str
,,+from evmoswallet.crypto.utils import rand_bytes
,,+
,,+bitcoin_curve = secp256k1()
,,+
,,+
,,+def sha3_256(x):
,,"+    return keccak.new(digest_bits=256, data=x)"
,,+
,,+
,,+def sha3(seed):
,,+    return sha3_256(seed).digest()
,,+
,,+
,,+def get_bytes(s):
,,"+    """"""Returns the byte representation of a hex- or byte-string."""""""
,,"+    if isinstance(s, bytes):"
,,+        b = s
,,"+    elif isinstance(s, str):"
,,+        b = bytes.fromhex(s)
,,+    else:
,,"+        raise TypeError(""s must be either 'bytes' or 'str'!"")"
,,+
,,+    return b
,,+
,,+
,,+class PrivateKeyBase:
,,"+    """""" Base class for both PrivateKey and HDPrivateKey."
,,+
,,+    As this class is a base class it should not be used directly.
,,+
,,+    Args:
,,+        k (int): The private key.
,,+
,,+    Returns:
,,+        PrivateKey: The object representing the private key.
,,"+    """""""
,,+    @staticmethod
,,+    def from_b58check(private_key):
,,"+        """""" Decodes a Base58Check encoded private-key."
,,+
,,+        Args:
,,+            private_key (str): A Base58Check encoded private key.
,,+
,,+        Returns:
,,+            PrivateKey: A PrivateKey object
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def __init__(self, k):"
,,+        self.key = k
,,+        self._public_key = None
,,+
,,+    @property
,,+    def public_key(self):
,,"+        """""" Returns the public key associated with this private key."
,,+
,,+        Returns:
,,+            PublicKey:
,,+                The PublicKey object that corresponds to this
,,+                private key.
,,"+        """""""
,,+        return self._public_key
,,+
,,"+    def raw_sign(self, message, do_hash=True):"
,,"+        """""" Signs message using this private key."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed. If a string is
,,+               provided it is assumed the encoding is 'ascii' and
,,"+               converted to bytes. If this is not the case, it is up"
,,+               to the caller to convert the string to bytes
,,+               appropriately and pass in the bytes.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+               to signing, False if not. This should always be left as"
,,+               True except in special situations which require doing
,,+               the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,+            ECPointAffine:
,,"+                a raw point (r = pt.x, s = pt.y) which is"
,,+                the signature.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def sign(self, message, do_hash=True):"
,,"+        """""" Signs message using this private key."
,,+
,,+        Note:
,,+            This differs from `raw_sign()` since it returns a
,,+            Signature object.
,,+
,,+        Args:
,,+            message (bytes or str): The message to be signed. If a
,,+               string is provided it is assumed the encoding is
,,+               'ascii' and converted to bytes. If this is not the
,,"+               case, it is up to the caller to convert the string to"
,,+               bytes appropriately and pass in the bytes.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+               to signing, False if not. This should always be left as"
,,+               True except in special situations which require doing
,,+               the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,+            Signature: The signature corresponding to message.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def sign_bitcoin(self, message, compressed=False):"
,,"+        """""" Signs a message using this private key such that it"
,,"+        is compatible with bitcoind, bx, and other Bitcoin"
,,+        clients/nodes/utilities.
,,+
,,+        Note:
,,"+            0x18 + b\""Bitcoin Signed Message:"" + newline + len(message) is"
,,+            prepended to the message before signing.
,,+
,,+        Args:
,,+            message (bytes or str): Message to be signed.
,,+            compressed (bool): True if the corresponding public key will be
,,+              used in compressed format. False if the uncompressed version
,,+              is used.
,,+
,,+        Returns:
,,+            bytes: A Base64-encoded byte string of the signed message.
,,+            The first byte of the encoded message contains information
,,"+            about how to recover the public key. In bitcoind parlance,"
,,+            this is the magic number containing the recovery ID and
,,+            whether or not the key was compressed or not. (This function
,,"+            always processes full, uncompressed public-keys, so the magic"
,,+            number will always be either 27 or 28).
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def to_b58check(self, testnet=False):"
,,"+        """""" Generates a Base58Check encoding of this private key."
,,+
,,+        Returns:
,,+            str: A Base58Check encoded string representing the key.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,+    def to_hex(self):
,,"+        """""" Generates a hex encoding of the serialized key."
,,+
,,+        Returns:
,,+           str: A hex encoded string representing the key.
,,"+        """""""
,,+        return bytes_to_str(bytes(self))
,,+
,,+    def __bytes__(self):
,,+        raise NotImplementedError
,,+
,,+    def __int__(self):
,,+        raise NotImplementedError
,,+
,,+
,,+class PublicKeyBase:
,,"+    """""" Base class for both PublicKey and HDPublicKey."
,,+
,,+    As this class is a base class it should not be used directly.
,,+
,,+    Args:
,,+        x (int): The x component of the public key point.
,,+        y (int): The y component of the public key point.
,,+
,,+    Returns:
,,+        PublicKey: The object representing the public key.
,,+
,,"+    """""""
,,+    @staticmethod
,,+    def from_bytes(key_bytes):
,,"+        """""" Generates a public key object from a byte (or hex) string."
,,+
,,+        Args:
,,+            key_bytes (bytes or str): A byte stream.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,+    @staticmethod
,,+    def from_private_key(private_key):
,,"+        """""" Generates a public key object from a PrivateKey object."
,,+
,,+        Args:
,,+            private_key (PrivateKey): The private key object from
,,+               which to derive this object.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,+        return private_key.public_key
,,+
,,+    def __init__(self):
,,+        pass
,,+
,,"+    def hash160(self, compressed=True):"
,,"+        """""" Return the RIPEMD-160 hash of the SHA-256 hash of the"
,,+        public key.
,,+
,,+        Args:
,,+            compressed (bool): Whether or not the compressed key should
,,+               be used.
,,+        Returns:
,,+            bytes: RIPEMD-160 byte string.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def address(self, compressed=True, testnet=False):"
,,"+        """""" Address property that returns the Base58Check"
,,+        encoded version of the HASH160.
,,+
,,+        Args:
,,+            compressed (bool): Whether or not the compressed key should
,,+               be used.
,,+            testnet (bool): Whether or not the key is intended for testnet
,,+               usage. False indicates mainnet usage.
,,+
,,+        Returns:
,,+            bytes: Base58Check encoded string
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,"+    def verify(self, message, signature, do_hash=True):"
,,"+        """""" Verifies that message was appropriately signed."
,,+
,,+        Args:
,,+            message (bytes): The message to be verified.
,,+            signature (Signature): A signature object.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+              to signing, False if not. This should always be left as"
,,+              True except in special situations which require doing
,,+              the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            verified (bool): True if the signature is verified, False"
,,+            otherwise.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,+    def to_hex(self):
,,"+        """""" Hex representation of the serialized byte stream."
,,+
,,+        Returns:
,,+            h (str): A hex-encoded string.
,,"+        """""""
,,+        return bytes_to_str(bytes(self))
,,+
,,+    def __bytes__(self):
,,+        raise NotImplementedError
,,+
,,+    def __int__(self):
,,+        raise NotImplementedError
,,+
,,+    @property
,,+    def compressed_bytes(self):
,,"+        """""" Byte string corresponding to a compressed representation"
,,+        of this public key.
,,+
,,+        Returns:
,,+            b (bytes): A 33-byte long byte string.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,+
,,+class PrivateKey(PrivateKeyBase):
,,"+    """""" Encapsulation of a Bitcoin ECDSA private key."
,,+
,,"+    This class provides capability to generate private keys,"
,,"+    obtain the corresponding public key, sign messages and"
,,+    serialize/deserialize into a variety of formats.
,,+
,,+    Args:
,,+        k (int): The private key.
,,+
,,+    Returns:
,,+        PrivateKey: The object representing the private key.
,,"+    """""""
,,+    TESTNET_VERSION = 0xEF
,,+    MAINNET_VERSION = 0x80
,,+
,,+    @staticmethod
,,+    def from_bytes(b):
,,"+        """""" Generates PrivateKey from the underlying bytes."
,,+
,,+        Args:
,,+            b (bytes): A byte stream containing a 256-bit (32-byte) integer.
,,+
,,+        Returns:
,,"+            tuple(PrivateKey, bytes): A PrivateKey object and the remainder"
,,+            of the bytes.
,,"+        """""""
,,+        if len(b) < 32:
,,+            raise ValueError('b must contain at least 32 bytes')
,,+
,,"+        return PrivateKey(int.from_bytes(b[:32], 'big'))"
,,+
,,+    @staticmethod
,,+    def from_hex(h):
,,"+        """""" Generates PrivateKey from a hex-encoded string."
,,+
,,+        Args:
,,+            h (str): A hex-encoded string containing a 256-bit
,,+                 (32-byte) integer.
,,+
,,+        Returns:
,,+            PrivateKey: A PrivateKey object.
,,"+        """""""
,,+        return PrivateKey.from_bytes(bytes.fromhex(h))
,,+
,,+    @staticmethod
,,+    def from_int(i):
,,"+        """""" Initializes a private key from an integer."
,,+
,,+        Args:
,,+            i (int): Integer that is the private key.
,,+
,,+        Returns:
,,+            PrivateKey: The object representing the private key.
,,"+        """""""
,,+        return PrivateKey(i)
,,+
,,+    @staticmethod
,,+    def from_b58check(private_key):
,,"+        """""" Decodes a Base58Check encoded private-key."
,,+
,,+        Args:
,,+            private_key (str): A Base58Check encoded private key.
,,+
,,+        Returns:
,,+            PrivateKey: A PrivateKey object
,,"+        """""""
,,+        b58dec = base58.b58decode_check(private_key)
,,+        version = b58dec[0]
,,"+        assert version in [PrivateKey.TESTNET_VERSION, PrivateKey.MAINNET_VERSION]"
,,+
,,"+        return PrivateKey(int.from_bytes(b58dec[1:], 'big'))"
,,+
,,+    @staticmethod
,,+    def from_random():
,,"+        """""" Initializes a private key from a random integer."
,,+
,,+        Returns:
,,+            PrivateKey: The object representing the private key.
,,"+        """""""
,,"+        return PrivateKey(random.SystemRandom().randrange(1, bitcoin_curve.n))"
,,+
,,"+    def __init__(self, k):"
,,+        self.key = k
,,+        self._public_key = None
,,+
,,+    @property
,,+    def public_key(self):
,,"+        """""" Returns the public key associated with this private key."
,,+
,,+        Returns:
,,+            PublicKey:
,,+                The PublicKey object that corresponds to this
,,+                private key.
,,"+        """""""
,,+        if self._public_key is None:
,,+            self._public_key = PublicKey.from_point(bitcoin_curve.public_key(self.key))
,,+        return self._public_key
,,+
,,"+    def raw_sign(self, message, do_hash=True):"
,,"+        """""" Signs message using this private key."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed. If a string is
,,+                provided it is assumed the encoding is 'ascii' and
,,"+                converted to bytes. If this is not the case, it is up"
,,+                to the caller to convert the string to bytes
,,+                appropriately and pass in the bytes.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+                to signing, False if not. This should always be left as"
,,+                True except in special situations which require doing
,,+                the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,+            ECPointAffine:
,,"+                a raw point (r = pt.x, s = pt.y) which is"
,,+                the signature.
,,"+        """""""
,,"+        if isinstance(message, str):"
,,"+            msg = bytes(message, 'ascii')"
,,"+        elif isinstance(message, bytes):"
,,+            msg = message
,,+        else:
,,+            raise TypeError('message must be either str or bytes!')
,,+
,,"+        sig_pt, rec_id = bitcoin_curve.sign(msg, self.key, do_hash)"
,,+
,,+        # Take care of large s:
,,"+        # Bitcoin deals with large s, by subtracting"
,,+        # s from the curve order. See:
,,+        # https://bitcointalk.org/index.php?topic=285142.30;wap2
,,+        if sig_pt.y >= (bitcoin_curve.n // 2):
,,"+            sig_pt = Point(sig_pt.x, bitcoin_curve.n - sig_pt.y)"
,,+            rec_id ^= 0x1
,,+
,,"+        return (sig_pt, rec_id)"
,,+
,,"+    def sign(self, message, do_hash=True):"
,,"+        """""" Signs message using this private key."
,,+
,,+        Note:
,,+            This differs from `raw_sign()` since it returns a Signature object.
,,+
,,+        Args:
,,+            message (bytes or str): The message to be signed. If a
,,+                string is provided it is assumed the encoding is
,,+                'ascii' and converted to bytes. If this is not the
,,"+                case, it is up to the caller to convert the string to"
,,+                bytes appropriately and pass in the bytes.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+                to signing, False if not. This should always be left as"
,,+                True except in special situations which require doing
,,+                the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,+            Signature: The signature corresponding to message.
,,"+        """""""
,,+        # Some BTC things want to have the recovery id to extract the public
,,"+        # key, so we should figure that out."
,,"+        sig_pt, rec_id = self.raw_sign(message, do_hash)"
,,+
,,"+        return Signature(sig_pt.x, sig_pt.y, rec_id)"
,,+
,,"+    def sign_bitcoin(self, message, compressed=False):"
,,"+        """""" Signs a message using this private key such that it"
,,"+        is compatible with bitcoind, bx, and other Bitcoin"
,,+        clients/nodes/utilities.
,,+
,,+        Note:
,,"+            0x18 + b\""Bitcoin Signed Message:"" + newline + len(message) is"
,,+            prepended to the message before signing.
,,+
,,+        Args:
,,+            message (bytes or str): Message to be signed.
,,+            compressed (bool): True if the corresponding public key will be
,,+              used in compressed format. False if the uncompressed version
,,+              is used.
,,+
,,+        Returns:
,,+            bytes: A Base64-encoded byte string of the signed message.
,,+            The first byte of the encoded message contains information
,,"+            about how to recover the public key. In bitcoind parlance,"
,,+            this is the magic number containing the recovery ID and
,,+            whether or not the key was compressed or not.
,,"+        """""""
,,"+        if isinstance(message, str):"
,,"+            msg_in = bytes(message, 'ascii')"
,,"+        elif isinstance(message, bytes):"
,,+            msg_in = message
,,+        else:
,,+            raise TypeError('message must be either str or bytes!')
,,+
,,+        msg = b'\x18Bitcoin Signed Message:\n' + bytes([len(msg_in)]) + msg_in
,,+        msg_hash = hashlib.sha256(msg).digest()
,,+
,,+        sig = self.sign(msg_hash)
,,+        comp_adder = 4 if compressed else 0
,,+        magic = 27 + sig.recovery_id + comp_adder
,,+
,,+        return base64.b64encode(bytes([magic]) + bytes(sig))
,,+
,,"+    def to_b58check(self, testnet=False):"
,,"+        """""" Generates a Base58Check encoding of this private key."
,,+
,,+        Returns:
,,+            str: A Base58Check encoded string representing the key.
,,"+        """""""
,,+        version = self.TESTNET_VERSION if testnet else self.MAINNET_VERSION
,,+        return base58.b58encode_check(bytes([version]) + bytes(self))
,,+
,,+    def __bytes__(self):
,,"+        return self.key.to_bytes(32, 'big')"
,,+
,,+    def __int__(self):
,,+        return self.key
,,+
,,+
,,+class PublicKey(PublicKeyBase):
,,"+    """""" Encapsulation of a Bitcoin ECDSA public key."
,,+
,,+    This class provides a high-level API to using an ECDSA public
,,"+    key, specifically for Bitcoin (secp256k1) purposes."
,,+
,,+    Args:
,,+        x (int): The x component of the public key point.
,,+        y (int): The y component of the public key point.
,,+
,,+    Returns:
,,+        PublicKey: The object representing the public key.
,,"+    """""""
,,+
,,+    TESTNET_VERSION = 0x6F
,,+    MAINNET_VERSION = 0x00
,,+
,,+    @staticmethod
,,+    def from_point(p):
,,"+        """""" Generates a public key object from any object"
,,"+        containing x, y coordinates."
,,+
,,+        Args:
,,"+            p (Point): An object containing a two-dimensional, affine"
,,+               representation of a point on the secp256k1 curve.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,"+        return PublicKey(p.x, p.y)"
,,+
,,+    @staticmethod
,,+    def from_int(i):
,,"+        """""" Generates a public key object from an integer."
,,+
,,+        Note:
,,+            This assumes that the upper 32 bytes of the integer
,,+            are the x component of the public key point and the
,,+            lower 32 bytes are the y component.
,,+
,,+        Args:
,,+            i (Bignum): A 512-bit integer representing the public
,,+               key point on the secp256k1 curve.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,"+        point = ECPointAffine.from_int(bitcoin_curve, i)"
,,+        return PublicKey.from_point(point)
,,+
,,+    @staticmethod
,,"+    def from_base64(b64str, testnet=False):"
,,"+        """""" Generates a public key object from a Base64 encoded string."
,,+
,,+        Args:
,,+            b64str (str): A Base64-encoded string.
,,"+            testnet (bool) (Optional): If True, changes the version that"
,,+               is prepended to the key.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,+        return PublicKey.from_bytes(base64.b64decode(b64str))
,,+
,,+    @staticmethod
,,+    def from_bytes(key_bytes):
,,"+        """""" Generates a public key object from a byte (or hex) string."
,,+
,,+        The byte stream must be of the SEC variety
,,+        (http://www.secg.org/): beginning with a single byte telling
,,"+        what key representation follows. A full, uncompressed key"
,,+        is represented by: 0x04 followed by 64 bytes containing
,,+        the x and y components of the point. For compressed keys
,,"+        with an even y component, 0x02 is followed by 32 bytes"
,,+        containing the x component. For compressed keys with an
,,"+        odd y component, 0x03 is followed by 32 bytes containing"
,,+        the x component.
,,+
,,+        Args:
,,+            key_bytes (bytes or str): A byte stream that conforms to the above.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,+        b = get_bytes(key_bytes)
,,+        key_bytes_len = len(b)
,,+
,,+        key_type = b[0]
,,+        if key_type == 0x04:
,,+            # Uncompressed
,,+            if key_bytes_len != 65:
,,+                raise ValueError('key_bytes must be exactly 65 bytes long when uncompressed.')
,,+
,,"+            x = int.from_bytes(b[1:33], 'big')"
,,"+            y = int.from_bytes(b[33:65], 'big')"
,,+        elif key_type == 0x02 or key_type == 0x03:
,,+            if key_bytes_len != 33:
,,+                raise ValueError('key_bytes must be exactly 33 bytes long when compressed.')
,,+
,,"+            x = int.from_bytes(b[1:33], 'big')"
,,+            ys = bitcoin_curve.y_from_x(x)
,,+
,,+            # Pick the one that corresponds to key_type
,,+            last_bit = key_type - 0x2
,,+            for y in ys:
,,+                if y & 0x1 == last_bit:
,,+                    break
,,+        else:
,,+            return None
,,+
,,"+        return PublicKey(x, y)"
,,+
,,+    @staticmethod
,,+    def from_hex(h):
,,"+        """""" Generates a public key object from a hex-encoded string."
,,+
,,+        See from_bytes() for requirements of the hex string.
,,+
,,+        Args:
,,+            h (str): A hex-encoded string.
,,+
,,+        Returns:
,,+            PublicKey: A PublicKey object.
,,"+        """""""
,,+        return PublicKey.from_bytes(h)
,,+
,,+    @staticmethod
,,"+    def from_signature(message, signature):"
,,"+        """""" Attempts to create PublicKey object by deriving it"
,,+        from the message and signature.
,,+
,,+        Args:
,,+            message (bytes): The message to be verified.
,,+            signature (Signature): The signature for message.
,,+               The recovery_id must not be None!
,,+
,,+        Returns:
,,+            PublicKey:
,,+                A PublicKey object derived from the
,,"+                signature, it it exists. None otherwise."
,,"+        """""""
,,+        if signature.recovery_id is None:
,,+            raise ValueError('The signature must have a recovery_id.')
,,+
,,+        msg = get_bytes(message)
,,"+        pub_keys = bitcoin_curve.recover_public_key(msg, signature, signature.recovery_id)"
,,+
,,"+        for k, recid in pub_keys:"
,,+            if signature.recovery_id is not None and recid == signature.recovery_id:
,,"+                return PublicKey(k.x, k.y)"
,,+
,,+        return None
,,+
,,+    @staticmethod
,,"+    def verify_bitcoin(message, signature, address):"
,,"+        """""" Verifies a message signed using PrivateKey.sign_bitcoin()"
,,"+        or any of the bitcoin utils (e.g. bitcoin-cli, bx, etc.)"
,,+
,,+        Args:
,,+            message(bytes): The message that the signature corresponds to.
,,+            signature (bytes or str): A Base64 encoded signature
,,+            address (str): Base58Check encoded address.
,,+
,,+        Returns:
,,"+            bool: True if the signature verified properly, False otherwise."
,,"+        """""""
,,+        magic_sig = base64.b64decode(signature)
,,+
,,+        magic = magic_sig[0]
,,+        sig = Signature.from_bytes(magic_sig[1:])
,,+        sig.recovery_id = (magic - 27) & 0x3
,,+        compressed = ((magic - 27) & 0x4) != 0
,,+
,,+        # Build the message that was signed
,,+        msg = b'\x18Bitcoin Signed Message:\n' + bytes([len(message)]) + message
,,+        msg_hash = hashlib.sha256(msg).digest()
,,+
,,"+        derived_public_key = PublicKey.from_signature(msg_hash, sig)"
,,+        if derived_public_key is None:
,,+            raise ValueError('Could not recover public key from the provided signature.')
,,+
,,"+        ver, h160 = address_to_key_hash(address)"
,,+        hash160 = derived_public_key.hash160(compressed)
,,+        if hash160 != h160:
,,+            return False
,,+
,,"+        return derived_public_key.verify(msg_hash, sig)"
,,+
,,"+    def __init__(self, x, y):"
,,"+        p = ECPointAffine(bitcoin_curve, x, y)"
,,+        if not bitcoin_curve.is_on_curve(p):
,,"+            raise ValueError('The provided (x, y) are not on the secp256k1 curve.')"
,,+
,,+        self.point = p
,,+
,,+        # RIPEMD-160 of SHA-256
,,+        r = hashlib.new('ripemd160')
,,+        r.update(hashlib.sha256(bytes(self)).digest())
,,+        self.ripe = r.digest()
,,+
,,+        r = hashlib.new('ripemd160')
,,+        r.update(hashlib.sha256(self.compressed_bytes).digest())
,,+        self.ripe_compressed = r.digest()
,,+
,,+        self.keccak = sha3(bytes(self)[1:])
,,+
,,"+    def hash160(self, compressed=True):"
,,"+        """""" Return the RIPEMD-160 hash of the SHA-256 hash of the"
,,+        public key.
,,+
,,+        Args:
,,+            compressed (bool): Whether or not the compressed key should
,,+               be used.
,,+        Returns:
,,+            bytes: RIPEMD-160 byte string.
,,"+        """""""
,,+        return self.ripe_compressed if compressed else self.ripe
,,+
,,"+    def address(self, compressed=True, testnet=False):"
,,"+        """""" Address property that returns the Base58Check"
,,+        encoded version of the HASH160.
,,+
,,+        Args:
,,+            compressed (bool): Whether or not the compressed key should
,,+               be used.
,,+            testnet (bool): Whether or not the key is intended for testnet
,,+               usage. False indicates mainnet usage.
,,+
,,+        Returns:
,,+            bytes: Base58Check encoded string
,,"+        """""""
,,+        version = '0x'
,,+        return version + binascii.hexlify(self.keccak[12:]).decode('ascii')
,,"+        # Put the version byte in front, 0x00 for Mainnet, 0x6F for testnet"
,,+        # version = bytes([self.TESTNET_VERSION]) if testnet else bytes([self.MAINNET_VERSION])
,,+        # return base58.b58encode_check(version + self.hash160(compressed))
,,+
,,"+    def verify(self, message, signature, do_hash=True):"
,,"+        """""" Verifies that message was appropriately signed."
,,+
,,+        Args:
,,+            message (bytes): The message to be verified.
,,+            signature (Signature): A signature object.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+              to signing, False if not. This should always be left as"
,,+              True except in special situations which require doing
,,+              the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            verified (bool): True if the signature is verified, False"
,,+            otherwise.
,,"+        """""""
,,+        msg = get_bytes(message)
,,"+        return bitcoin_curve.verify(msg, signature, self.point, do_hash)"
,,+
,,+    def to_base64(self):
,,"+        """""" Hex representation of the serialized byte stream."
,,+
,,+        Returns:
,,+            b (str): A Base64-encoded string.
,,"+        """""""
,,+        return base64.b64encode(bytes(self))
,,+
,,+    def __int__(self):
,,+        mask = 2**256 - 1
,,+        return ((self.point.x & mask) << bitcoin_curve.nlen) | (self.point.y & mask)
,,+
,,+    def __bytes__(self):
,,+        return bytes(self.point)
,,+
,,+    @property
,,+    def compressed_bytes(self):
,,"+        """""" Byte string corresponding to a compressed representation"
,,+        of this public key.
,,+
,,+        Returns:
,,+            b (bytes): A 33-byte long byte string.
,,"+        """""""
,,+        return self.point.compressed_bytes
,,+
,,+
,,+class Signature:
,,"+    """""" Encapsulation of a ECDSA signature for Bitcoin purposes."
,,+
,,+    Args:
,,+        r (Bignum): r component of the signature.
,,+        s (Bignum): s component of the signature.
,,+        recovery_id (int) (Optional): Must be between 0 and 3 specifying
,,+           which of the public keys generated by the algorithm specified
,,+           in http://www.secg.org/sec1-v2.pdf Section 4.1.6 (Public Key
,,+           Recovery Operation) is the correct one for this signature.
,,+
,,+    Returns:
,,+        sig (Signature): A Signature object.
,,"+    """""""
,,+    @staticmethod
,,+    def from_der(der):
,,"+        """""" Decodes a Signature that was DER-encoded."
,,+
,,+        Args:
,,+            der (bytes or str): The DER encoding to be decoded.
,,+
,,+        Returns:
,,+            Signature: The deserialized signature.
,,"+        """""""
,,+        d = get_bytes(der)
,,+        # d must conform to (from btcd):
,,+        # [0 ] 0x30      - ASN.1 identifier for sequence
,,+        # [1 ] <1-byte>  - total remaining length
,,+        # [2 ] 0x02      - ASN.1 identifier to specify an integer follows
,,+        # [3 ] <1-byte>  - length of R
,,+        # [4.] <bytes>   - R
,,+        # [..] 0x02      - ASN.1 identifier to specify an integer follows
,,+        # [..] <1-byte>  - length of S
,,+        # [..] <bytes>   - S
,,+
,,+        # 6 bytes + R (min. 1 byte) + S (min. 1 byte)
,,+        if len(d) < 8:
,,+            raise ValueError('DER signature string is too short.')
,,+        # 6 bytes + R (max. 33 bytes) + S (max. 33 bytes)
,,+        if len(d) > 72:
,,+            raise ValueError('DER signature string is too long.')
,,+        if d[0] != 0x30:
,,+            raise ValueError('DER signature does not start with 0x30.')
,,+        if d[1] != len(d[2:]):
,,+            raise ValueError('DER signature length incorrect.')
,,+
,,+        total_length = d[1]
,,+
,,+        if d[2] != 0x02:
,,+            raise ValueError('DER signature no 1st int marker.')
,,+        if d[3] <= 0 or d[3] > (total_length - 7):
,,+            raise ValueError('DER signature incorrect R length.')
,,+
,,"+        # Grab R, check for errors"
,,+        rlen = d[3]
,,+        s_magic_index = 4 + rlen
,,+        rb = d[4:s_magic_index]
,,+
,,+        if rb[0] & 0x80 != 0:
,,+            raise ValueError('DER signature R is negative.')
,,+        if len(rb) > 1 and rb[0] == 0 and rb[1] & 0x80 != 0x80:
,,+            raise ValueError('DER signature R is excessively padded.')
,,+
,,"+        r = int.from_bytes(rb, 'big')"
,,+
,,"+        # Grab S, check for errors"
,,+        if d[s_magic_index] != 0x02:
,,+            raise ValueError('DER signature no 2nd int marker.')
,,+        slen_index = s_magic_index + 1
,,+        slen = d[slen_index]
,,+        if slen <= 0 or slen > len(d) - (slen_index + 1):
,,+            raise ValueError('DER signature incorrect S length.')
,,+
,,+        sb = d[slen_index + 1:]
,,+
,,+        if sb[0] & 0x80 != 0:
,,+            raise ValueError('DER signature S is negative.')
,,+        if len(sb) > 1 and sb[0] == 0 and sb[1] & 0x80 != 0x80:
,,+            raise ValueError('DER signature S is excessively padded.')
,,+
,,"+        s = int.from_bytes(sb, 'big')"
,,+
,,+        if r < 1 or r >= bitcoin_curve.n:
,,+            raise ValueError('DER signature R is not between 1 and N - 1.')
,,+        if s < 1 or s >= bitcoin_curve.n:
,,+            raise ValueError('DER signature S is not between 1 and N - 1.')
,,+
,,"+        return Signature(r, s)"
,,+
,,+    @staticmethod
,,+    def from_base64(b64str):
,,"+        """""" Generates a signature object from a Base64 encoded string."
,,+
,,+        Args:
,,+            b64str (str): A Base64-encoded string.
,,+
,,+        Returns:
,,+            Signature: A Signature object.
,,"+        """""""
,,+        return Signature.from_bytes(base64.b64decode(b64str))
,,+
,,+    @staticmethod
,,+    def from_bytes(b):
,,"+        """""" Extracts the r and s components from a byte string."
,,+
,,+        Args:
,,+            b (bytes): A 64-byte long string. The first 32 bytes are
,,+               extracted as the r component and the second 32 bytes
,,+               are extracted as the s component.
,,+
,,+        Returns:
,,+            Signature: A Signature object.
,,+
,,+        Raises:
,,+            ValueError: If signature is incorrect length
,,"+        """""""
,,+        if len(b) != 64:
,,+            raise ValueError('from_bytes: Signature length != 64.')
,,"+        r = int.from_bytes(b[0:32], 'big')"
,,"+        s = int.from_bytes(b[32:64], 'big')"
,,"+        return Signature(r, s)"
,,+
,,+    @staticmethod
,,+    def from_hex(h):
,,"+        """""" Extracts the r and s components from a hex-encoded string."
,,+
,,+        Args:
,,+            h (str): A 64-byte (128 character) long string. The first
,,+               32 bytes are extracted as the r component and the
,,+               second 32 bytes are extracted as the s component.
,,+
,,+        Returns:
,,+            Signature: A Signature object.
,,"+        """""""
,,+        return Signature.from_bytes(bytes.fromhex(h))
,,+
,,"+    def __init__(self, r, s, recovery_id=None):"
,,+        self.r = r
,,+        self.s = s
,,+        self.recovery_id = recovery_id
,,+
,,+    @property
,,+    def x(self):
,,"+        """""" Convenience property for any method that requires"
,,+            this object to provide a Point interface.
,,"+        """""""
,,+        return self.r
,,+
,,+    @property
,,+    def y(self):
,,"+        """""" Convenience property for any method that requires"
,,+            this object to provide a Point interface.
,,"+        """""""
,,+        return self.s
,,+
,,+    def _canonicalize(self):
,,+        rv = []
,,"+        for x in [self.r, self.s]:"
,,+            # Compute minimum bytes to represent integer
,,+            bl = math.ceil(x.bit_length() / 8)
,,+            # Make sure it's at least one byte in length
,,+            if bl == 0:
,,+                bl += 1
,,"+            x_bytes = x.to_bytes(bl, 'big')"
,,+
,,+            # make sure there's no way it could be interpreted
,,+            # as a negative integer
,,+            if x_bytes[0] & 0x80:
,,+                x_bytes = bytes([0]) + x_bytes
,,+
,,+            rv.append(x_bytes)
,,+
,,+        return rv
,,+
,,+    def to_der(self):
,,"+        """""" Encodes this signature using DER"
,,+
,,+        Returns:
,,"+            bytes: The DER encoding of (self.r, self.s)."
,,"+        """""""
,,+        # Output should be:
,,+        # 0x30 <length> 0x02 <length r> r 0x02 <length s> s
,,"+        r, s = self._canonicalize()"
,,+
,,+        total_length = 6 + len(r) + len(s)
,,"+        der = bytes([0x30, total_length - 2, 0x02, len(r)]) + r + bytes([0x02, len(s)]) + s"
,,+        return der
,,+
,,+    def to_hex(self):
,,"+        """""" Hex representation of the serialized byte stream."
,,+
,,+        Returns:
,,+            str: A hex-encoded string.
,,"+        """""""
,,+        return bytes_to_str(bytes(self))
,,+
,,+    def to_base64(self):
,,"+        """""" Hex representation of the serialized byte stream."
,,+
,,+        Returns:
,,+            str: A Base64-encoded string.
,,"+        """""""
,,+        return base64.b64encode(bytes(self))
,,+
,,+    def __bytes__(self):
,,+        nbytes = math.ceil(bitcoin_curve.nlen / 8)
,,"+        return self.r.to_bytes(nbytes, 'big') + self.s.to_bytes(nbytes, 'big')"
,,+
,,+
,,+class HDKey:
,,"+    """""" Base class for HDPrivateKey and HDPublicKey."
,,+
,,+    Args:
,,+        key (PrivateKey or PublicKey): The underlying simple private or
,,+           public key that is used to sign/verify.
,,+        chain_code (bytes): The chain code associated with the HD key.
,,+        depth (int): How many levels below the master node this key is. By
,,"+           definition, depth = 0 for the master node."
,,+        index (int): A value between 0 and 0xffffffff indicating the child
,,+           number. Values >= 0x80000000 are considered hardened children.
,,+        parent_fingerprint (bytes): The fingerprint of the parent node. This
,,+           is 0x00000000 for the master node.
,,+
,,+    Returns:
,,+        HDKey: An HDKey object.
,,"+    """""""
,,+    @staticmethod
,,+    def from_b58check(key):
,,"+        """""" Decodes a Base58Check encoded key."
,,+
,,+        The encoding must conform to the description in:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format
,,+
,,+        Args:
,,+            key (str): A Base58Check encoded key.
,,+
,,+        Returns:
,,+            HDPrivateKey or HDPublicKey:
,,+                Either an HD private or
,,"+                public key object, depending on what was serialized."
,,"+        """""""
,,+        return HDKey.from_bytes(base58.b58decode_check(key))
,,+
,,+    @staticmethod
,,+    def from_bytes(b):
,,"+        """""" Generates either a HDPrivateKey or HDPublicKey from the underlying"
,,+        bytes.
,,+
,,+        The serialization must conform to the description in:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format
,,+
,,+        Args:
,,+            b (bytes): A byte stream conforming to the above.
,,+
,,+        Returns:
,,+            HDPrivateKey or HDPublicKey:
,,+                Either an HD private or
,,"+                public key object, depending on what was serialized."
,,"+        """""""
,,+        if len(b) < 78:
,,+            raise ValueError('b must be at least 78 bytes long.')
,,+
,,"+        version = int.from_bytes(b[:4], 'big')"
,,+        depth = b[4]
,,+        parent_fingerprint = b[5:9]
,,"+        index = int.from_bytes(b[9:13], 'big')"
,,+        chain_code = b[13:45]
,,+        key_bytes = b[45:78]
,,+
,,+        rv = None
,,+        if version == HDPrivateKey.MAINNET_VERSION or version == HDPrivateKey.TESTNET_VERSION:
,,+            if key_bytes[0] != 0:
,,+                raise ValueError('First byte of private key must be 0x00!')
,,+
,,"+            private_key = int.from_bytes(key_bytes[1:], 'big')"
,,+            rv = HDPrivateKey(
,,"+                key=private_key,"
,,"+                chain_code=chain_code,"
,,"+                index=index,"
,,"+                depth=depth,"
,,"+                parent_fingerprint=parent_fingerprint,"
,,+            )
,,+        elif version == HDPublicKey.MAINNET_VERSION or version == HDPublicKey.TESTNET_VERSION:
,,+            if key_bytes[0] != 0x02 and key_bytes[0] != 0x03:
,,+                raise ValueError('First byte of public key must be 0x02 or 0x03!')
,,+
,,+            public_key = PublicKey.from_bytes(key_bytes)
,,+            rv = HDPublicKey(
,,"+                x=public_key.point.x,"
,,"+                y=public_key.point.y,"
,,"+                chain_code=chain_code,"
,,"+                index=index,"
,,"+                depth=depth,"
,,"+                parent_fingerprint=parent_fingerprint,"
,,+            )
,,+        else:
,,+            raise ValueError('incorrect encoding.')
,,+
,,+        return rv
,,+
,,+    @staticmethod
,,+    def from_hex(h):
,,"+        """""" Generates either a HDPrivateKey or HDPublicKey from the underlying"
,,+        hex-encoded string.
,,+
,,+        The serialization must conform to the description in:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#serialization-format
,,+
,,+        Args:
,,+            h (str): A hex-encoded string conforming to the above.
,,+
,,+        Returns:
,,+            HDPrivateKey or HDPublicKey:
,,+                Either an HD private or
,,"+                public key object, depending on what was serialized."
,,"+        """""""
,,+        return HDKey.from_bytes(bytes.fromhex(h))
,,+
,,+    @staticmethod
,,"+    def from_path(root_key, path):"
,,+        p = HDKey.parse_path(path)
,,+
,,+        if p[0] == 'm':
,,+            if root_key.master:
,,+                p = p[1:]
,,+            else:
,,"+                raise ValueError(""root_key must be a master key if 'm' is the first element of the path."")"
,,+
,,+        keys = [root_key]
,,+        for i in p:
,,"+            if isinstance(i, str):"
,,"+                hardened = i[-1] == ""'"""
,,"+                index = int(i[:-1], 0) | 0x80000000 if hardened else int(i, 0)"
,,+            else:
,,+                index = i
,,+            k = keys[-1]
,,+            klass = k.__class__
,,"+            keys.append(klass.from_parent(k, index))"
,,+
,,+        return keys
,,+
,,+    @staticmethod
,,+    def parse_path(path):
,,"+        if isinstance(path, str):"
,,"+            # Remove trailing ""/"""
,,+            p = path.rstrip('/').split('/')
,,"+        elif isinstance(path, bytes):"
,,+            p = path.decode('utf-8').rstrip('/').split('/')
,,+        else:
,,+            p = list(path)
,,+
,,+        return p
,,+
,,+    @staticmethod
,,+    def path_from_indices(x):
,,+        p = []
,,+        for n in x:
,,+            if n == 'm':
,,+                p.append(n)
,,+            else:
,,+                if n & 0x80000000:
,,+                    _n = n & 0x7fffffff
,,"+                    p.append(str(_n) + ""'"")"
,,+                else:
,,+                    p.append(str(n))
,,+
,,+        return '/'.join(p)
,,+
,,"+    def __init__(self, key, chain_code, index, depth, parent_fingerprint):"
,,+        if index < 0 or index > 0xffffffff:
,,+            raise ValueError('index is out of range: 0 <= index <= 2**32 - 1')
,,+
,,"+        if not isinstance(chain_code, bytes):"
,,+            raise TypeError('chain_code must be bytes')
,,+
,,+        self._key = key
,,+        self.chain_code = chain_code
,,+        self.depth = depth
,,+        self.index = index
,,+
,,+        self.parent_fingerprint = get_bytes(parent_fingerprint)
,,+
,,+    @property
,,+    def master(self):
,,"+        """""" Whether or not this is a master node."
,,+
,,+        Returns:
,,"+            bool: True if this is a master node, False otherwise."
,,"+        """""""
,,+        return self.depth == 0
,,+
,,+    @property
,,+    def hardened(self):
,,"+        """""" Whether or not this is a hardened node."
,,+
,,+        Hardened nodes are those with indices >= 0x80000000.
,,+
,,+        Returns:
,,"+            bool: True if this is hardened, False otherwise."
,,"+        """""""
,,"+        # A hardened key is a key with index >= 2 ** 31, so"
,,+        # we check that the MSB of a uint32 is set.
,,+        return self.index & 0x80000000
,,+
,,+    @property
,,+    def identifier(self):
,,"+        """""" Returns the identifier for the key."
,,+
,,+        A key's identifier and fingerprint are defined as:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#key-identifiers
,,+
,,+        Returns:
,,+            bytes: A 20-byte RIPEMD-160 hash.
,,"+        """""""
,,+        raise NotImplementedError
,,+
,,+    @property
,,+    def fingerprint(self):
,,"+        """""" Returns the key's fingerprint, which is the first 4 bytes"
,,+        of its identifier.
,,+
,,+        A key's identifier and fingerprint are defined as:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#key-identifiers
,,+
,,+        Returns:
,,+            bytes: The first 4 bytes of the RIPEMD-160 hash.
,,"+        """""""
,,+        return self.identifier[:4]
,,+
,,"+    def to_b58check(self, testnet=False):"
,,"+        """""" Generates a Base58Check encoding of this key."
,,+
,,+        Args:
,,+            testnet (bool): True if the key is to be used with
,,"+                testnet, False otherwise."
,,+        Returns:
,,+            str: A Base58Check encoded string representing the key.
,,"+        """""""
,,+        b = self.testnet_bytes if testnet else bytes(self)
,,+        return base58.b58encode_check(b)
,,+
,,"+    def _serialize(self, testnet=False):"
,,+        version = self.TESTNET_VERSION if testnet else self.MAINNET_VERSION
,,"+        key_bytes = self._key.compressed_bytes if isinstance(self, HDPublicKey) else b'\x00' + bytes(self._key)"
,,"+        return (version.to_bytes(length=4, byteorder='big') + bytes([self.depth]) + self.parent_fingerprint +"
,,"+                self.index.to_bytes(length=4, byteorder='big') + self.chain_code + key_bytes)"
,,+
,,+    def __bytes__(self):
,,+        return self._serialize()
,,+
,,+    @property
,,+    def testnet_bytes(self):
,,"+        """""" Serialization of the key for testnet."
,,+
,,+        Returns:
,,+            bytes:
,,"+                A 78-byte serialization of the key, specifically for"
,,+                testnet (i.e. the first 2 bytes will be 0x0435).
,,"+        """""""
,,+        return self._serialize(True)
,,+
,,+
,,"+class HDPrivateKey(HDKey, PrivateKeyBase):"
,,"+    """""" Implements an HD Private Key according to BIP-0032:"
,,+    https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
,,+
,,"+    For the vast majority of use cases, the 3 static functions"
,,"+    (HDPrivateKey.master_key_from_entropy,"
,,+    HDPrivateKey.master_key_from_seed and
,,+    HDPrivateKey.from_parent) will be used rather than directly
,,+    constructing an object.
,,+
,,+    Args:
,,+        key (PrivateKey or PublicKey): The underlying simple private or
,,+           public key that is used to sign/verify.
,,+        chain_code (bytes): The chain code associated with the HD key.
,,+        depth (int): How many levels below the master node this key is. By
,,"+           definition, depth = 0 for the master node."
,,+        index (int): A value between 0 and 0xffffffff indicating the child
,,+           number. Values >= 0x80000000 are considered hardened children.
,,+        parent_fingerprint (bytes): The fingerprint of the parent node. This
,,+           is 0x00000000 for the master node.
,,+
,,+    Returns:
,,+        HDKey: An HDKey object.
,,+
,,"+    """""""
,,+    MAINNET_VERSION = 0x0488ADE4
,,+    TESTNET_VERSION = 0x04358394
,,+
,,+    @staticmethod
,,"+    def master_key_from_mnemonic(mnemonic, passphrase=''):"
,,"+        """""" Generates a master key from a mnemonic."
,,+
,,+        Args:
,,+            mnemonic (str): The mnemonic sentence representing
,,+               the seed from which to generate the master key.
,,+            passphrase (str): Password if one was used.
,,+
,,+        Returns:
,,+            HDPrivateKey: the master private key.
,,"+        """""""
,,"+        return HDPrivateKey.master_key_from_seed(Mnemonic.to_seed(mnemonic, passphrase))"
,,+
,,+    @staticmethod
,,"+    def master_key_from_entropy(passphrase='', strength=128):"
,,"+        """""" Generates a master key from system entropy."
,,+
,,+        Args:
,,+            strength (int): Amount of entropy desired. This should be
,,+               a multiple of 32 between 128 and 256.
,,+            passphrase (str): An optional passphrase for the generated
,,+               mnemonic string.
,,+
,,+        Returns:
,,"+            HDPrivateKey, str:"
,,+                a tuple consisting of the master
,,+                private key and a mnemonic string from which the seed
,,+                can be recovered.
,,"+        """""""
,,+        if strength % 32 != 0:
,,+            raise ValueError('strength must be a multiple of 32')
,,+        if strength < 128 or strength > 256:
,,+            raise ValueError('strength should be >= 128 and <= 256')
,,+        entropy = rand_bytes(strength // 8)
,,+        m = Mnemonic(language='english')
,,+        n = m.to_mnemonic(entropy)
,,"+        return HDPrivateKey.master_key_from_seed(Mnemonic.to_seed(n, passphrase)), n"
,,+
,,+    @staticmethod
,,+    def master_key_from_seed(seed):
,,"+        """""" Generates a master key from a provided seed."
,,+
,,+        Args:
,,+            seed (bytes or str): a string of bytes or a hex string
,,+
,,+        Returns:
,,+            HDPrivateKey: the master private key.
,,"+        """""""
,,+        S = get_bytes(seed)
,,"+        hmacI = hmac.new(b'Bitcoin seed', S, hashlib.sha512).digest()"
,,"+        Il, Ir = hmacI[:32], hmacI[32:]"
,,"+        parse_Il = int.from_bytes(Il, 'big')"
,,+        if parse_Il == 0 or parse_Il >= bitcoin_curve.n:
,,"+            raise ValueError('Bad seed, resulting in invalid key!')"
,,+
,,"+        return HDPrivateKey(key=parse_Il, chain_code=Ir, index=0, depth=0)"
,,+
,,+    @staticmethod
,,"+    def from_parent(parent_key, i):"
,,"+        """""" Derives a child private key from a parent"
,,+        private key. It is not possible to derive a child
,,+        private key from a public parent key.
,,+
,,+        Args:
,,+            parent_private_key (HDPrivateKey):
,,"+        """""""
,,"+        if not isinstance(parent_key, HDPrivateKey):"
,,+            raise TypeError('parent_key must be an HDPrivateKey object.')
,,+
,,+        hmac_key = parent_key.chain_code
,,+        if i & 0x80000000:
,,"+            hmac_data = b'\x00' + bytes(parent_key._key) + i.to_bytes(length=4, byteorder='big')"
,,+        else:
,,"+            hmac_data = parent_key.public_key.compressed_bytes + i.to_bytes(length=4, byteorder='big')"
,,+
,,"+        hmacI = hmac.new(hmac_key, hmac_data, hashlib.sha512).digest()"
,,"+        Il, Ir = hmacI[:32], hmacI[32:]"
,,+
,,"+        parse_Il = int.from_bytes(Il, 'big')"
,,+        if parse_Il >= bitcoin_curve.n:
,,+            return None
,,+
,,+        child_key = (parse_Il + parent_key._key.key) % bitcoin_curve.n
,,+
,,+        if child_key == 0:
,,+            # Incredibly unlucky choice
,,+            return None
,,+
,,+        child_depth = parent_key.depth + 1
,,+        return HDPrivateKey(
,,"+            key=child_key,"
,,"+            chain_code=Ir,"
,,"+            index=i,"
,,"+            depth=child_depth,"
,,"+            parent_fingerprint=parent_key.fingerprint,"
,,+        )
,,+
,,"+    def __init__(self, key, chain_code, index, depth, parent_fingerprint=b'\x00\x00\x00\x00'):"
,,+        if index < 0 or index > 0xffffffff:
,,+            raise ValueError('index is out of range: 0 <= index <= 2**32 - 1')
,,+
,,+        private_key = PrivateKey(key)
,,"+        HDKey.__init__(self, private_key, chain_code, index, depth, parent_fingerprint)"
,,+        self._public_key = None
,,+
,,+    @property
,,+    def public_key(self):
,,"+        """""" Returns the public key associated with this private key."
,,+
,,+        Returns:
,,+            HDPublicKey:
,,+                The HDPublicKey object that corresponds to this
,,+                private key.
,,"+        """""""
,,+        if self._public_key is None:
,,+            self._public_key = HDPublicKey(
,,"+                x=self._key.public_key.point.x,"
,,"+                y=self._key.public_key.point.y,"
,,"+                chain_code=self.chain_code,"
,,"+                index=self.index,"
,,"+                depth=self.depth,"
,,"+                parent_fingerprint=self.parent_fingerprint,"
,,+            )
,,+
,,+        return self._public_key
,,+
,,"+    def raw_sign(self, message, do_hash=True):"
,,"+        """""" Signs message using the underlying non-extended private key."
,,+
,,+        Args:
,,+            message (bytes): The message to be signed. If a string is
,,+                provided it is assumed the encoding is 'ascii' and
,,"+                converted to bytes. If this is not the case, it is up"
,,+                to the caller to convert the string to bytes
,,+                appropriately and pass in the bytes.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+                to signing, False if not. This should always be left as"
,,+                True except in special situations which require doing
,,+                the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,+            ECPointAffine:
,,"+                a raw point (r = pt.x, s = pt.y) which is"
,,+                the signature.
,,"+        """""""
,,"+        return self._key.raw_sign(message, do_hash)"
,,+
,,"+    def sign(self, message, do_hash=True):"
,,"+        """""" Signs message using the underlying non-extended private key."
,,+
,,+        Note:
,,+            This differs from `raw_sign()` since it returns a Signature object.
,,+
,,+        Args:
,,+            message (bytes or str): The message to be signed. If a
,,+                string is provided it is assumed the encoding is
,,+                'ascii' and converted to bytes. If this is not the
,,"+                case, it is up to the caller to convert the string to"
,,+                bytes appropriately and pass in the bytes.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+                to signing, False if not. This should always be left as"
,,+                True except in special situations which require doing
,,+                the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,+            Signature: The signature corresponding to message.
,,"+        """""""
,,"+        return self._key.sign(message, do_hash)"
,,+
,,"+    def sign_bitcoin(self, message, compressed=False):"
,,"+        """""" Signs a message using the underlying non-extended private"
,,"+        key such that it is compatible with bitcoind, bx, and other"
,,+        Bitcoin clients/nodes/utilities.
,,+
,,+        Note:
,,"+            0x18 + b\""Bitcoin Signed Message:"" + newline + len(message) is"
,,+            prepended to the message before signing.
,,+
,,+        Args:
,,+            message (bytes or str): Message to be signed.
,,+            compressed (bool):
,,+                True if the corresponding public key will be
,,+                used in compressed format. False if the uncompressed version
,,+                is used.
,,+
,,+        Returns:
,,+            bytes: A Base64-encoded byte string of the signed message.
,,+            The first byte of the encoded message contains information
,,"+            about how to recover the public key. In bitcoind parlance,"
,,+            this is the magic number containing the recovery ID and
,,+            whether or not the key was compressed or not. (This function
,,"+            always processes full, uncompressed public-keys, so the"
,,+            magic number will always be either 27 or 28).
,,"+        """""""
,,+
,,"+        return self._key.sign_bitcoin(message, compressed)"
,,+
,,+    @property
,,+    def identifier(self):
,,"+        """""" Returns the identifier for the key."
,,+
,,+        A key's identifier and fingerprint are defined as:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#key-identifiers
,,+
,,"+        In this case, it will return the RIPEMD-160 hash of the"
,,+        corresponding public key.
,,+
,,+        Returns:
,,+            bytes: A 20-byte RIPEMD-160 hash.
,,"+        """""""
,,+        return self.public_key.hash160()
,,+
,,+    def __int__(self):
,,+        return int(self.key)
,,+
,,+
,,"+class HDPublicKey(HDKey, PublicKeyBase):"
,,"+    """""" Implements an HD Public Key according to BIP-0032:"
,,+    https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki
,,+
,,"+    For the vast majority of use cases, the static function"
,,+    HDPublicKey.from_parent() will be used rather than directly
,,+    constructing an object.
,,+
,,+    Args:
,,+        x (int): x component of the point representing the public key.
,,+        y (int): y component of the point representing the public key.
,,+        chain_code (bytes): The chain code associated with the HD key.
,,+        depth (int): How many levels below the master node this key is. By
,,"+           definition, depth = 0 for the master node."
,,+        index (int): A value between 0 and 0xffffffff indicating the child
,,+           number. Values >= 0x80000000 are considered hardened children.
,,+        parent_fingerprint (bytes): The fingerprint of the parent node. This
,,+           is 0x00000000 for the master node.
,,+
,,+    Returns:
,,+        HDPublicKey: An HDPublicKey object.
,,+
,,"+    """""""
,,+
,,+    MAINNET_VERSION = 0x0488B21E
,,+    TESTNET_VERSION = 0x043587CF
,,+
,,+    @staticmethod
,,"+    def from_parent(parent_key, i):"
,,"+        """""""
,,"+        """""""
,,"+        if isinstance(parent_key, HDPrivateKey):"
,,+            # Get child private key
,,"+            return HDPrivateKey.from_parent(parent_key, i).public_key"
,,"+        elif isinstance(parent_key, HDPublicKey):"
,,+            if i & 0x80000000:
,,"+                raise ValueError(""Can't generate a hardened child key from a parent public key."")"
,,+            else:
,,+                hmacI = hmac.new(
,,"+                    parent_key.chain_code,"
,,"+                    parent_key.compressed_bytes + i.to_bytes(length=4, byteorder='big'),"
,,"+                    hashlib.sha512,"
,,+                ).digest()
,,"+                Il, Ir = hmacI[:32], hmacI[32:]"
,,"+                parse_Il = int.from_bytes(Il, 'big')"
,,+                if parse_Il >= bitcoin_curve.n:
,,+                    return None
,,+
,,+                temp_priv_key = PrivateKey(parse_Il)
,,+                Ki = temp_priv_key.public_key.point + parent_key._key.point
,,+                if Ki.infinity:
,,+                    return None
,,+
,,+                child_depth = parent_key.depth + 1
,,+                return HDPublicKey(
,,"+                    x=Ki.x,"
,,"+                    y=Ki.y,"
,,"+                    chain_code=Ir,"
,,"+                    index=i,"
,,"+                    depth=child_depth,"
,,"+                    parent_fingerprint=parent_key.fingerprint,"
,,+                )
,,+        else:
,,+            raise TypeError('parent_key must be either a HDPrivateKey or HDPublicKey object')
,,+
,,"+    def __init__(self, x, y, chain_code, index, depth, parent_fingerprint=b'\x00\x00\x00\x00'):"
,,"+        key = PublicKey(x, y)"
,,"+        HDKey.__init__(self, key, chain_code, index, depth, parent_fingerprint)"
,,+        PublicKeyBase.__init__(self)
,,+
,,+    @property
,,+    def identifier(self):
,,"+        """""" Returns the identifier for the key."
,,+
,,+        A key's identifier and fingerprint are defined as:
,,+        https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#key-identifiers
,,+
,,"+        In this case, it will return the RIPEMD-160 hash of the"
,,+        non-extended public key.
,,+
,,+        Returns:
,,+            bytes: A 20-byte RIPEMD-160 hash.
,,"+        """""""
,,+        return self.hash160()
,,+
,,"+    def hash160(self, compressed=True):"
,,"+        """""" Return the RIPEMD-160 hash of the SHA-256 hash of the"
,,+        non-extended public key.
,,+
,,+        Note:
,,+            This always returns the hash of the compressed version of
,,+            the public key.
,,+
,,+        Returns:
,,+            bytes: RIPEMD-160 byte string.
,,"+        """""""
,,+        return self._key.hash160(True)
,,+
,,"+    def address(self, compressed=True, testnet=False):"
,,"+        """""" Address property that returns the Base58Check"
,,+        encoded version of the HASH160.
,,+
,,+        Args:
,,+            compressed (bool): Whether or not the compressed key should
,,+               be used.
,,+            testnet (bool): Whether or not the key is intended for testnet
,,+               usage. False indicates mainnet usage.
,,+
,,+        Returns:
,,+            bytes: Base58Check encoded string
,,"+        """""""
,,"+        return self._key.address(True, testnet)"
,,+
,,"+    def verify(self, message, signature, do_hash=True):"
,,"+        """""" Verifies that message was appropriately signed."
,,+
,,+        Args:
,,+            message (bytes): The message to be verified.
,,+            signature (Signature): A signature object.
,,+            do_hash (bool): True if the message should be hashed prior
,,"+                to signing, False if not. This should always be left as"
,,+                True except in special situations which require doing
,,+                the hash outside (e.g. handling Bitcoin bugs).
,,+
,,+        Returns:
,,"+            verified (bool): True if the signature is verified, False"
,,+            otherwise.
,,"+        """""""
,,"+        return self._key.verify(message, signature, do_hash)"
,,+
,,+    @property
,,+    def compressed_bytes(self):
,,"+        """""" Byte string corresponding to a compressed representation"
,,+        of this public key.
,,+
,,+        Returns:
,,+            b (bytes): A 33-byte long byte string.
,,"+        """""""
,,+        return self._key.compressed_bytes
,,+from evmoswallet import Wallet
,,+
,,+seed = (
,,+    'report spend crisp crisp world shock morning hour spoon problem one hole program piano donkey width today view canoe clap brick bundle rose book'  # NOQA: E501
,,+)
,,+
,,+w = Wallet(seed)
,,+print(w.eth_address)
,,+print(w.private_key)
,,+base58 == 2.1.0
,,+coincurve==15.0.1
,,+mnemonic == 0.20
,,+pycryptodomex==3.11.0
,,+[metadata]
,,+name = evmoswallet
,,+version = 1.0.0
,,+description = Evmos wallet utils.
,,+long_description = file: README.md
,,+long_description_content_type = text/markdown
,,+url = https://github.com/hanchon-live/evmoswallet
,,+author = Hanchon
,,+author_email = guillermo.paoletti@gmail.com
,,+license = MIT
,,+license_file = LICENSE
,,+classifiers =
,,+    License :: OSI Approved :: MIT License
,,+    Operating System :: OS Independent
,,+    Programming Language :: Python :: 3
,,+    Programming Language :: Python :: 3 :: Only
,,+    Programming Language :: Python :: 3.6
,,+    Programming Language :: Python :: 3.7
,,+    Programming Language :: Python :: 3.8
,,+    Programming Language :: Python :: 3.9
,,+    Programming Language :: Python :: 3.10
,,+
,,+[options]
,,+packages = find:
,,+python_requires = >=3.6
,,+install_requires =
,,+    base58 == 2.1.0
,,+    pycryptodomex==3.11.0
,,+    mnemonic == 0.20
,,+    coincurve==15.0.1
,,+
,,+[autopep8]
,,+max_line_length = 120
,,+
,,+[flake8]
,,+max_line_length = 120
,,+
,,+[yapf]
,,+column_limit = 120
,,+based_on_style = pep8
,,+from setuptools import setup
,,+
,,+setup()
,,+import pytest
,,+
,,+from evmoswallet.converter import eth_to_evmos
,,+from evmoswallet.converter import evmos_to_eth
,,+
,,+
,,+@pytest.mark.parametrize(
,,"+    'input, output',"
,,+    [
,,"+        ('evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5', '0xe7e3654bc1ea915e7216d8193ef8dd7d5dae987f'),"
,,"+        ('cosmos1wze8mn5nsgl9qrgazq6a92fvh7m5e6psjcx2du', None),"
,,"+        ('', None),"
,,"+        ('evmos1123', None),"
,,"+    ],"
,,+)
,,"+def test_evmosToEth(input, output):"
,,+    assert evmos_to_eth(input) == output
,,+
,,+
,,+@pytest.mark.parametrize(
,,"+    'input, output',"
,,+    [
,,"+        ('0xe7e3654bc1ea915e7216d8193ef8dd7d5dae987f', 'evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5'),"
,,"+        ('cosmos1wze8mn5nsgl9qrgazq6a92fvh7m5e6psjcx2du', None),"
,,"+        ('evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5', None),"
,,"+        ('', None),"
,,"+    ],"
,,+)
,,"+def test_ethToEvmos(input, output):"
,,+    assert eth_to_evmos(input) == output
,,+from evmoswallet import Wallet
,,+
,,+
,,+def test_wallet():
,,+    seed = (
,,+        'report spend crisp crisp world shock morning hour spoon problem one hole program piano donkey width today view canoe clap brick bundle rose book'  # NOQA: E501
,,+    )
,,+    wallet = Wallet(seed)
,,+
,,+    assert wallet.eth_address == '0xe7e3654bc1ea915e7216d8193ef8dd7d5dae987f'
,,+    assert wallet.evmos_address == 'evmos1ul3k2j7pa2g4uuskmqvna7xa04w6axrl85alz5'
,,+    assert wallet.private_key == bytes.fromhex('8721109b7244925c0480f4172546b8b53dfe87845274070fbe8e6da739d1b813')
,,+
,,+
,,+def test_sign():
,,+    seed = (
,,+        'garment seat help gallery ride divide truth smooth end chunk ten cross badge want vehicle mirror dismiss remind crouch base crouch palm leader dinner'  # NOQA: E501
,,+    )
,,+
,,+    wallet = Wallet(seed)
,,+    input = bytes([
,,"+        177, 240, 144, 132, 71, 52, 192, 86, 100, 12, 4, 148, 127, 217, 62, 166, 254, 121, 39, 134, 16, 193, 151, 209,"
,,"+        7, 181, 85, 226, 30, 52, 62, 7"
,,+    ])
,,+    output = bytes([
,,"+        245, 167, 163, 221, 231, 60, 6, 188, 101, 237, 235, 104, 205, 107, 214, 180, 27, 213, 16, 161, 154, 8, 180, 244,"
,,"+        1, 136, 124, 205, 163, 59, 93, 3, 35, 24, 142, 200, 223, 233, 21, 51, 199, 110, 174, 174, 237, 115, 2, 104, 131,"
,,"+        241, 235, 156, 137, 31, 182, 244, 214, 186, 161, 183, 140, 131, 141, 233, 0"
,,+    ])
,,+
,,+    assert wallet.sign(input) == output
